""" 问题描述
给出整数n(1<=n<=3e3)和一个长度为n的整数组a,其中a[i](1<a[i]<1e9)代表第i个商品的价格，i从0开始计数。
如果这n个商品的排列中，每个商品左边至多有一个商品比它贵，那么我们称这个排列为 好排列。
问有多少种好排列。
注:这题如果真出大概要加MOD。因为ans=2**(n-1)
"""

""" 方法1:dp
我们先把数组a排序，然后考虑dp
方程: dp[i][j] 表示前i个数、当最大的数在位置j上时好排列的的数目。
答案: sum(dp[n-1][0..n-1])
初始:    
    dp[0][0] = 1, 这个是显然的，如果只有一个数，它必在第一个位置，且左边没有比它大的数，一定是好排列。
    dp[1][0] = dp[1][1] = 1,如果只看前两个数，只有两种排列，大的数位置分别在0/1上，同样都是好排列。
转移:
    假设我们已经处理完前i-1个商品的dp状态，现在要放第i个商品，注意由于数组排序了，第i个商品是当前最大商品。
    1) 如果第i个商品放在最后一个位置，即i上，那么i本身不会造成非法影响，只需要保证前i-1个商品就是好排列。
        即dp[i][i] = sum(dp[i-1][0..i-1])    
    2) 如果第i个商品放在0个位置上，那么后边1..i的数据必须是升序的，否则一定会出现有一个商品左边有两个大于它的情况。
        (解释:假设不是升序的，则存在k<j且a[k]>a[j](其中0<k<j<=i),已知a[0]>a[j],即有两个大的0,k.)
        必须升序，则只有一种排列。
        即dp[i][0] = 1
    从1)和2) 扩展到第i个商品(即当前最大)放到第j个位置上的情况:
        0..j-1部分只需要是个好排列即可,方案数=sum(dp[j-1][0..j-1]), 其中j>0
        j+1..i部分必须是升序，且一定是次大的那(i-j)个数(这里保证右半边所有数都不小于左半边),即一种,方案数=1, 其中j<i
        j的取值0~i。
        根据乘法原理左×右即可
        即:dp[i][j] = sum(dp[j-1][0..j-1]) if j>0 else 1
tips:我们写代码时会发现答案与商品价格无关，只与n有关。
时间复杂度O(n*n*n)，空间复杂度O(n*n)。       
"""

""" 方法2:dp
根据方法1能很容易的写出代码solve1(n)。
方法1的复杂度是O(n**3)的，考虑优化一下。
发现计算时使用前边状态一定是sum(dp[j][0..j]，这个sum其实就是n=j时答案，考虑把这个sum直接存成一个数。
那么
定义dp[i]为用前i个数时的好排列数目(直接答案)。
转移:dp[i] = sum(dp[j] for j in range(i)) + 1
初始:dp[1] = 1
时间复杂度O(n*n)，空间复杂度O(n)
"""

""" 方法3:公式 ans=2**(n-1)，时间复杂度O(1)(快速幂取模lg(n))，空间复杂度O(1)
测试了方法1和2后，发现答案长这样:  明显ans[n] = 2**(n-1)
仔细看一眼方法2的公式，发现就是幂次的递推，因为每个数都是二进制上的1，那么前边所有sum起来其实是一个1111111,再加1就是新的2的幂即1000000。
-----
n ans1 ans2
-----
1 1 1
2 2 2
3 4 4
4 8 8
5 16 16
6 32 32
7 64 64
8 128 128
9 256 256
10 512 512
-----
这里给出n=1~4的所有排列:
发现一个规律,每次从i-1增长到i时，排列的末位i-1有i-1个，i也有i-1个，是成倍增长的。
1:  1
2:  12
    21
3:  123
    132
    312
    213
4:  1234
    1243
    1423
    4123
    2143
    1324
    3124
    2134
"""


def solve3(n):
    return 2 ** (n - 1)


def solve2(n):
    if n <= 2:
        return n
    dp = [0] * n
    dp[0] = 1
    for i in range(1, n):
        dp[i] = sum(dp[j] for j in range(i)) + 1
    return dp[-1]


def solve1(n):
    if n <= 2:
        return n
    dp = [[0] * n for _ in range(n)]
    dp[0][0] = dp[1][0] = dp[1][1] = 1
    for i in range(2, n):
        for j in range(i + 1):
            dp[i][j] = sum(dp[j - 1][:j]) if j else 1
    return sum(dp[-1])


if __name__ == '__main__':
    questions = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    for q in questions:
        print(q, solve1(q), solve2(q), solve3(q))
