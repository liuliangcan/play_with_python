题目描述（点击单元格可以打开链接，右键复制）
https://codeforces.com/problemset/problem/148/E

输入 n(≤100) m(≤1e4) 和 n 个双端队列（dq），对于每个 dq，先输入 k(≤100) 表示 dq 的大小，然后输入 dq 中的 k 个数，范围在 [1,100]。所有 k 之和 ≥m。

你需要从这 n 个 dq 中取出 m 个数，输出这 m 个数的和的最大值。

提示：1e8 可过。
https://codeforces.com/problemset/problem/219/D

输入 n(2≤n≤2e5) 和 n-1 条边 v w，表示一条 v->w 的有向边。（节点编号从 1 开始）
保证输入构成一棵树。

你可以把边反向，即 v->w 改成 w->v。
定义 f(x) 表示以 x 为根时，要让 x 能够到达任意点，需要反向的边的数量。
输出 min(f(x))，以及所有等于 min(f(x)) 的节点编号（按升序输出）。
https://codeforces.com/contest/1525/problem/D

输入 n(≤5000) 和长为 n 的数组 a，其中只有 0 和 1。保证 1 的数量不超过 n/2。
a[i]=0 表示位置 i 处有一把椅子，a[i]=1 表示位置 i 处有一个人。

一把椅子只能坐一个人。
一个人从 i 移动到 j 的耗时为 abs(i-j)。
问所有人都坐到椅子上，所有人的耗时之和最小是多少？
https://codeforces.com/problemset/problem/1554/C

输入 t(≤3e4) 表示 t 组数据，每组数据输入两个整数 n 和 m，均在 [0,1e9] 范围内。

定义数组 a = [n xor 0, n xor 1, n xor 2, ..., n xor m]。
输出不在 a 中的最小非负整数。
https://codeforces.com/problemset/problem/1552/D

输入 t(≤20) 表示 t 组数据，每组数据输入 n(≤10) 和长为 n 的数组 a(-1e5≤a[i]≤1e5)。

如果存在一个长为 n 的数组 b，对于任意 i，都存在 j 和 k，使得 a[i]=b[j]-b[k]，则输出 YES，否则输出 NO。
注意 j 可以等于 k。
https://codeforces.com/problemset/problem/388/B

输入 k(1≤k≤1e9)。
构造一个节点个数不超过 1000 的简单无向图（节点编号从 1 开始），使得从节点 1 到节点 2 的最短路径的数量恰好为 k。
输出 n 以及一个 n*n 的邻接矩阵 g，如果 i 和 j 之间有边，则 g[i][j]='Y'，否则为 'N'。
注意不能有自环，即 g[i][i] 必须为 'N'。

进阶：请最小化 n。

注：这个构造方案可以用来 hack 一些用方案数取模来做连通性判定的代码。
https://codeforces.com/problemset/problem/1659/D

输入 t(≤1000) 表示 t 组数据，每组数据输入 n(≤2e5) 和长为 n 的数组 c(0≤c[i]≤n)。
所有数据的 n 之和不超过 2e5。

对于只有 0 和 1 的数组 a，定义 b[i] 为把 a 的前 i 个元素从小到大排序后的新数组（下标从 1 开始）。
定义 c[j] = b[1][j] + b[2][j] + ... + b[n][j]。
现在数组 c 输入给你了，请你构造任意一个符合要求的数组 a。输入保证数组 a 存在。

*本题做法不止一种，欢迎在群内交流。
https://codeforces.com/problemset/problem/708/B

对于 01 字符串 s，定义 f(x,y) 表示子序列 [x,y] 在 s 中的出现次数。
输入 f(0,0), f(0,1), f(1,0) 和 f(1,1)，范围在 [0,1e9]。
请构造任意一个满足输入的非空字符串 s。
如果不存在，输出 Impossible。
注：子序列是从 s 中删除某些元素得到的。

可能是道易错题
https://codeforces.com/problemset/problem/1179/B

输入 n m (n*m≤1e6)，表示一个 n 行 m 列的棋盘，行列编号从 1 开始。
初始时，你在 (1,1)。每一步，你可以使用一个方向向量 (dx,dy)，然后从当前位置 (x,y) 移动到 (x+dx,y+dy)。
你需要访问每个格子恰好一次，且每一步使用的方向向量互不相同。
如果存在这样的移动方案，输出任意一组符合要求的 n*m 个坐标，表示你每一步所在的位置。否则输出 -1。
https://codeforces.com/problemset/problem/584/C

输入 n t(0≤t≤n≤1e5) 和两个长度均为 n 的字符串 s1 和 s2，均由小写字母组成。

定义 f(a,b) 表示 a[i]!=b[i] 的下标数量。
构造一个长为 n 的，由小写字母组成的字符串 s3，使得 f(s1,s3)=f(s2,s3)=t。
如果无法构造，输出 -1。
https://codeforces.com/problemset/problem/5/C

输入括号字符串 s，长度不超过 1e6。

输出 s 的最长合法括号子串的长度和数量。
如果不存在，输出 0 1。
https://codeforces.com/problemset/problem/600/C

输入字符串 s，长度不超过 2e5，由小写字母组成。

你可以修改多个 s[i]，使得修改后的 s，通过重新排列，可以得到回文串。
设最少修改 x 次。输出修改 x 次且重排后字典序最小的回文串。

https://codeforces.com/problemset/problem/1272/E

输入 n(≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)，下标从 1 开始。

从位置 i，你可以移动到位置 i-a[i] 或者 i+a[i]，移动后的位置必须在 [1,n] 内。
定义 d(i) 表示从位置 i 出发，移动到某个位置 j 的最小移动次数，要求 a[i] 和 a[j] 的奇偶性不同。如果不存在这样的 j，则 d(i) 为 -1。
输出 d(1),d(2),...,d(n)。
https://codeforces.com/problemset/problem/1095/E

输入 n(≤1e6) 和长为 n 的括号字符串 s。

你必须执行如下操作恰好一次：
选择一个下标 i，如果 s[i] 是 ')'，则修改为 '('，反之亦然。

有多少个不同的 i，可以使 s 是一个合法的括号字符串？

思考：如果可以改两个 s[i] 呢？
https://codeforces.com/problemset/problem/1213/D2

输入 n k (1≤k≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤2e5)。

每次操作你可以让一个 a[i] 变为 floor(a[i]/2)。
要想得到至少 k 个相同的数，最少需要多少次操作？

进阶：你能想出一个时间复杂度为 O(max(a)) 的做法吗？
https://codeforces.com/contest/1374/problem/E1

输入 n k (1≤k≤n≤2e5)，表示有 n 本书，然后输入 n 行，每行输入 t(1≤t≤1e4) a b，其中 a=0/1 表示 A 不喜欢/喜欢这本书，b=0/1 表示 B 不喜欢/喜欢这本书。

你需要选择一些书，使得其中至少有 k 本是 A 喜欢的，至少有 k 本是 B 喜欢的。
如果无法满足输出 -1，否则输出所选书的 t 之和的最小值。

进阶：如果要选恰好 m 本书呢？
https://codeforces.com/contest/1324/problem/E

输入 n(≤2000) h L R (0≤L≤R<h≤2000) 和长为 n 的数组 a(1≤a[i]<h)。

对于每个 a[i]，你可以把它减一，或者保持不变（换句话说，每个 a[i] 至多 -1 一次）。
定义前缀和 s[0]=a[0], s[i]=s[i-1]+a[i]。
如果 s[i]%h 落在闭区间 [L,R] 内，则分数加一。
最大化分数。
https://codeforces.com/problemset/problem/1361/B

输入 t(≤1e5) 表示 t 组数据，每组数据输入 n(≤1e6) p(1≤p≤1e6) 和长为 n 的数组 k(0≤k[i]≤1e6)。所有数据的 n 之和不超过 1e6。

从这 n 个数中选出若干个数（可以为空）组成一组，剩余的数组成另一组。
每组计算 pow(p,k[i]) 之和。
输出这两个和的差值的最小值，对结果模 1e9+7。
https://codeforces.com/problemset/problem/1141/F2

输入 n(≤1500) 和长为 n 的数组 a(-1e5≤a[i]≤1e5)，下标从 1 开始。

你需要从 a 中选出尽量多的非空连续子数组，这些子数组不能重叠，且元素和相等。
输出子数组的个数 k，然后输出 k 行，每行两个数表示子数组的左右端点。
可以按任意顺序输出，多种方案可以输出任意一种。
https://codeforces.com/contest/1442/problem/A

输入 t(≤3e4) 表示 t 组数据，每组数据输入 n(≤3e4) 和长为 n 的数组 a(1≤a[i]≤1e6)。所有数据的 n 之和不超过 3e4。

每次操作，你可以把 a 的任意一个前缀或后缀的元素都减一。
你能否把所有 a[i] 都变成 0？输出 YES 或 NO。
https://atcoder.jp/contests/arc111/tasks/arc111_b

输入 n(≤2e5) 和一个 n 行 2 列的矩阵，矩阵元素范围 [1,4e5]。
从每行中恰好选一个数，你最多能选出多少个不同的数？
https://codeforces.com/problemset/problem/1695/C

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤1e3) m(≤1e3) 和一个 n 行 m 列的矩阵，元素值只有 -1 和 1。所有数据的 n*m 之和不超过 1e6。

你从矩阵左上出发，走到右下，每步只能向下或者向右。
路径上的元素和能否为 0？输出 YES 或 NO。
https://atcoder.jp/contests/arc119/tasks/arc119_c

输入 n(2≤n≤3e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。

每次操作，你可以选择两个相邻的数字，把它们都加一，或者都减一。
对于 a 的一个连续子数组 b，如果可以通过执行任意多次操作，使 b 的所有元素为 0，则称 b 为好子数组。
输出 a 的好子数组的数量。
https://atcoder.jp/contests/arc148/tasks/arc148_c

输入 n(2≤n≤2e5) q(≤2e5)，然后输入 p2,p3,...,pn 表示一棵根为 1 的树，pi 表示点 i 的父节点。
然后输入 q 个询问，每个询问先输入 m，然后输入 m 个互不相同的特殊节点 v1,v2,...,vm。所有询问的 m 之和不超过 2e5。

每个节点都有一盏灯，其中特殊节点的灯打开，其余节点的灯关闭。
每次操作，你可以选择一棵子树，切换子树内所有灯的开/闭状态。
对每个询问，回答：要使所有灯关闭，至少需要多少次操作。
https://atcoder.jp/contests/arc153/tasks/arc153_c

输入 n(1≤n≤2e5) 和长为 n 的数组 a，只包含 -1 和 1。

你需要构造一个严格递增数组 b，元素范围在 [-1e12,1e12]，且 sum(a[i]*b[i]) = 0
如果无法构造，输出 No；否则输出 Yes 和数组 b。
https://codeforces.com/contest/797/problem/D

输入 n(1≤n≤1e5) 和一棵二叉树的 n 个节点（节点按照输入顺序编号为 1 到 n）。每行输入 x l r，对应节点值 [0,1e9] 和左右儿子的编号，如果没有则为 -1。
输入保证恰好有一个节点没有父节点，即根节点。

如下是一个在二叉搜索树中查找元素的伪代码：
bool find(TreeNode t, int x) {
    if (t == null)
        return false;
    if (t.value == x)
        return true;
    if (x < t.value)
        return find(t.left, x);
    else
        return find(t.right, x);
}
find(root, x);

把二叉树的每个节点值应用上述代码，输出你会得到多少次 false。
注意节点值可能有重复的。
https://atcoder.jp/contests/abc270/tasks/abc270_e

输入 n(≤1e5) k(≤1e12) 和长为 n 的数组 a(0≤a[i]≤1e12, sum(a)≥k)

有 n 堆苹果顺时针围成一圈，第 i 堆有 a[i] 个苹果。
你从第一堆苹果开始吃，每堆吃了一个苹果后，就顺时针走到下一个还有苹果的堆，重复该过程，直到吃了 k 个苹果。
输出此时每堆剩余苹果数。

你能想出两种不同的做法吗？
https://codeforces.com/contest/1359/problem/D

输入 n(1≤n≤1e5) 和长为 n 的数组 a(-30≤a[i]≤30)。
设 b 为 a 的一个非空连续子数组。
输出 sum(b)-max(b) 的最大值。
https://atcoder.jp/contests/arc145/tasks/arc145_a

输入 n(2≤n≤2e5) 和长为 n 的字符串 s，仅包含 'A' 和 'B'。

你可以执行如下操作任意多次：
选择两个相邻字符 s[i] 和 s[i+1]，把 s[i] 替换成 'A'，s[i+1] 替换成 'B'。
能否使 s 变成回文串？输出 Yes 或 No。
https://codeforces.com/contest/961/problem/D

输入 n(≤1e5) 和 n 个点 (xi,yi)，范围在 [-1e9,1e9]，所有点都是不同的。
你能否画至多两条直线，覆盖所有点？输出 YES 或 NO。
https://codeforces.com/contest/1661/problem/C

输入 t(≤2e4) 表示 t 组数据，每组数据输入 n(≤3e5) 和长为 n 的数组 h(1≤h[i]≤1e9)，表示 n 棵树的高度。所有数据的 n 之和不超过 3e5。

在第 1,3,5,... 天，你可以把一棵树的高度+1，或者不做任何事。
在第 2,4,6,... 天，你可以把一棵树的高度+2，或者不做任何事。
要使所有树的高度一样，至少要多少天？
https://codeforces.com/problemset/problem/1661/D

输入 n k(k≤n≤3e5) 和长为 n 的数组 b(1≤b[i]≤1e12)。

初始你有一个长为 n 的数组 a，元素都为 0。
每次操作你要选一个长度恰好等于 k 的连续子数组，从左到右，第1个数加1，第2个数加2，……第k个数加k。
要使每个 a[i] >= b[i]，至少需要操作多少次？
https://codeforces.com/problemset/problem/1598/D

输入 t(≤5e4) 表示 t 组数据，每组数据输入 n(3≤n≤2e5) 和 n 个点 (xi,yi)，横纵坐标都在 [1,n] 内。没有重复的点。所有数据的 n 之和不超过 2e5。

从 n 个点中选出 3 个点，满足「横坐标互不相同」或者「纵坐标互不相同」。
输出有多少种选择方案。注意选的是组合，(1,2,3) 和 (3,2,1) 算相同的方案。
https://codeforces.com/problemset/problem/1721/D

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤1e5) 和两个长为 n 的数组 a b，元素范围在 [0,2^30)。所有数据的 n 之和不超过 1e5。

数组 b 可以随意打乱。
输出 (a[1] XOR b[1]) AND (a[2] XOR b[2]) AND ... AND (a[n] XOR b[n]) 的最大值。
https://atcoder.jp/contests/abc222/tasks/abc222_f

输入 n(2≤n≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始），每条边输入两个端点和边权。
然后输入 n 个数 d，d[i] 表示点 i 的点权。

定义 f(x,y) = 从 x 到 y 的简单路径的边权之和，再加上 d[y]。
定义 g(x) = max{f(x,i)}，这里 i 取遍 1~n 的所有不为 x 的点。
输出 g(1),g(2),...,g(n)。
https://codeforces.com/problemset/problem/1409/E

输入 t(≤2e4) 表示 t 组数据，每组数据输入 n(≤2e5) k(≤1e9) 和长为 n 的数组 a(1≤a[i]≤1e9) 和数组 b。所有数据的 n 之和不超过 2e5。

把 a[i] 标记到数轴上，问两条长为 k 的线段，最多可以覆盖多少 a[i]（线段端点可以覆盖 a[i]）。
注意：数组 b 是没用的，但是你要读入它。

扩展：有 m 条线段：2209. 用地毯覆盖后的最少白色砖块
https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/
https://codeforces.com/problemset/problem/1691/D

输入 t(≤1e5) 表示 t 组数据，每组数据输入 n(≤2e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)。所有数据的 n 之和不超过 2e5。

请你判断，对数组 a 的每个非空子数组 b，是否都有 max(b) >= sum(b)？
如果是，输出 YES，否则输出 NO。
注：子数组是连续的。

进阶：做到 O(n) 时间复杂度。
https://codeforces.com/problemset/problem/777/D

输入 n(≤5e5) 和长为 n 的字符串数组 a，每个字符串都以 # 开头，所有字符串的长度之和不超过 5e5。
你可以把字符串的任意后缀去掉。
输出使得 a 变为字典序升序，至少需要去掉多少字符。
https://codeforces.com/problemset/problem/1490/G

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n(≤2e5) m(≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)，表示一个由数组 a 无限重复的序列 b。
然后输入 m 个询问，每个询问输入 x(1≤x≤1e9)。
对每个询问，输出 b 的前缀和中首次 ≥x 的下标（下标从 0 开始），如果不存在，输出 -1。
所有数据的 n 之和、m 之和均不超过 2e5。
https://codeforces.com/problemset/problem/547/B

输入 n(n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
定义 f(x) 为 a 中「长为 x 的连续子数组的最小值」的最大值。
输出 f(1), f(2), ..., f(n)。
https://codeforces.com/problemset/problem/1358/D

输入 n(n≤2e5) x 和长为 n 的数组 d(1≤d[i]≤1e6 且 1≤x≤sum(d))。
在某地，一年有 n 月，其中第 i 月有 d[i] 天，天数从 1 到 d[i]，在第 j 天你可以得到 j 元。
问在该地连续呆 x 天你最多能得到多少元。
注意：从当年最后一月呆到下一年的第一月是可以的。
https://codeforces.com/problemset/problem/1370/D

输入 n k (2≤k≤n≤2e5) 和长为 n 的数组 a (1≤a[i]≤1e9)。
从 a 中选出一个长为 k 的子序列 s，下标从 1 开始。
定义 x=max(s[1],s[3],s[5],...)，y=max(s[2],s[4],s[6],...)
输出 min(x,y) 的最小值。
注：子序列不一定是连续的。
http://codeforces.com/problemset/problem/1739/D

输入 t(≤1e4) 表示 t 组数据，每组数据输入 n k(0≤k<n≤2e5)，有一颗 n 个节点的树，输入 n-1 个数 p[2],p[3],...,p[n]，p[i] 表示点 i 的父节点为 p[i]。
所有数据的 n 之和不超过 2e5。
你可以做如下操作至多 k 次：
断开 p[i] 和 i 之间的边，然后在 1 和 i 之间连边。
输出操作后，这颗树的最小高度。
高度的定义为 1 到最远叶子节点的路径的边数。
https://codeforces.com/problemset/problem/1718/A2

输入 t(≤500) 表示 t 组数据，每组数据输入 n(≤1e5) 和长为 n 的数组 a (0≤a[i]<2^30)。
所有数据的 n 之和不超过 1e5。
每次操作你可以把 a 的下标从 L 到 R 的元素都异或一个数，花费为 ceil((R-L+1)/2)。
输出把 a 的所有元素都变成 0 的最小代价。
https://codeforces.com/problemset/problem/1733/D2

输入 t(≤1000) 表示 t 组数据，每组数据输入 n(5≤n≤5000) x y(1~1e9) 和两个长为 n 的二进制数 s 和 t。
所有数据的 n 之和不超过 5000。
每次操作你可以把 s 的两个比特位翻转（0 变 1，1 变 0），如果两个比特位相邻，则代价为 x，否则为 y。
输出把 s 变成 t 的最小代价，如果无法做到，输出 -1。

进阶：你能做到 O(n) 时间复杂度吗？
https://atcoder.jp/contests/abc249/tasks/abc249_f

初始时 x=0。
输入 n k(k≤n≤2e5)，以及 n 个操作，每个操作是如下两种之一：
"1 y"，表示把 x 替换成 y；
"2 y"，表示 x+=y。(-1e9≤y≤1e9)
你可以跳过至多 k 个操作，你需要最大化最后的 x，输出这个最大值。
https://codeforces.com/problemset/problem/379/D

输入 k(3≤k≤50) x(0≤x≤1e9) n(1≤n≤100) m(1≤m≤100)。
你需要构造长分别为 n 和 m 的字符串 s[1] 和 s[2]，它们只能包含大写字母。
然后按照 s[i]=s[i-2]+s[i-1] 的方式，生成字符串 s[k]，要求子串 "AC" 在 s[k] 中恰好出现 x 次。
如果可以构造，输出任意符合要求的 s[1] 和 s[2]，否则输出 "Happy new year!"。
https://atcoder.jp/contests/abc259/tasks/abc259_f

输入 n(≤3e5)，长为 n 的数组 d，和一颗带权树的 n-1 条边，边权 [-1e9,1e9]。
d[i] 不会超过点 i 的度数。
移除一些边，使得点 i 的度数不超过 d[i]。
输出剩余边的边权之和的最大值。
https://atcoder.jp/contests/abc267/tasks/abc267_f

输入 n(≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始）。
然后输入 q(≤2e5) 和 q 个询问，每个询问输入 u 和 k。
输出到 u 的距离为 k 的任意一个点。如果这个点不存在则输出 -1。
距离指两点最短路上的边的数目。
https://atcoder.jp/contests/abc268/tasks/abc268_f

输入 n(≤2e5) 和 n 个字符串，总长度不超过 2e5。
每个字符串包含 X 和数字 1~9。
重排这些字符串，然后拼接成一个字符串 t。
对每个 1≤i<j≤len(t)，如果 t[i]=X 且 t[j]=1 则得 1 分，如果 t[i]=X 且 t[j]=2 则得 2 分，依此类推。
输出你最多可以得到多少分。
https://atcoder.jp/contests/abc270/tasks/abc270_f

输入 n m (≤2e5)。有 n 个岛屿。
输入 n 个数，表示在第 i 个岛屿上修建机场的花费(≤1e9)。如果两个岛都有机场，则可以互相到达。
输入 n 个数，表示在第 i 个岛屿上修建港口的花费(≤1e9)。如果两个岛都有港口，则可以互相到达。
输入 m 条边，每条边输入 a b z 表示在岛屿 a 和 b 造桥的花费为 z(≤1e9)。
输出使得任意两个岛可以互相到达的最小花费。
https://atcoder.jp/contests/abc269/tasks/abc269_f

输入 n m (≤1e9) q(≤2e5)。表示一个 n 行 m 列的矩阵。
第 i 行第 j 列的元素为 (i-1)*m+j，但是如果 i+j 是奇数，则该元素为 0。
输入 q 个询问，每个询问输入 r1 r2 c1 c2。
对每个询问，输出所有在第 r1~r2 行 c1~c2 列的元素之和，模 998244353。
https://atcoder.jp/contests/abc271/tasks/abc271_e

输入 n m k (≤2e5)，然后输入 m 条边，每条边输入两个点 x y（表示从 x 到 y 的一条有向边，点的编号 1~n）和一个值在 [1,1e9] 内的边权，每条边的编号 1~m。
图中没有自环，但可能有重边。
然后输入一个长为 k 的数组 a (1≤e[i]≤m)。
找到一条从 1 到 n 的路径，满足路径上的边的编号是 a 的子序列。
输出满足这个要求的路径的最短长度。如果不存在，输出 -1。
https://atcoder.jp/contests/abc273/tasks/abc273_e

一开始你有一个空数组 a 和一个 1e9 页的笔记本，每页上都记录着一个空数组。
有四种类型的操作：
ADD x：在 a 的末尾添加元素 x (1≤x≤1e9)。
DELETE：如果 a 不为空，删除 a 的最后一个元素。
SAVE y：把 a 记在第 y 页上（覆盖原来的数组）。
LOAD z：把 a 替换为第 z 页上的数组。

输入 q(≤5e5) 和 q 个操作。
在每个操作结束后，你需要输出 a 的最后一个元素（数组为空时输出 -1）。
https://atcoder.jp/contests/abc275/tasks/abc275_f

输入 n(≤3000) m(≤3000) 和长为 n 的数组 a (1≤a[i]≤3000)。
每次操作你可以删除 a 的一个非空连续子数组。
定义 f(x) 表示使 sum(a) = x 的最小操作次数。
输出 f(1), f(2), ..., f(m)。
https://atcoder.jp/contests/abc266/tasks/abc266_f

输入 n (3≤n≤2e5) 和 n 条边，点的编号在 [1,n] 内，表示一个没有重边和自环的无向连通图。
然后输入 q(≤2e5) 表示有 q 个询问，每个询问输入两个数 x 和 y (1≤x<y≤n)。
对于每个询问，如果 x 和 y 之间只存在唯一的简单路径，则输出 Yes，否则输出 No。
https://atcoder.jp/contests/abc272/tasks/abc272_e

输入 n(≤2e5) m(≤2e5) 和长为 n 的整数数组 a (-1e9≤a[i]≤1e9)，下标从 1 开始。
执行如下操作 m 次：
对 1~n 的每个 i，把 a[i] += i。
每次操作后，输出 mex(a)，即不在 a 中的最小非负整数。
https://atcoder.jp/contests/abc214/tasks/abc214_e

输入 t(≤2e5) 表示 t 组数据，每组数据输入 n(≤2e5) 和 n 个区间 [L,R]，范围在 [1,1e9]。
所有数据的 n 之和不超过 2e5。

你有 n 个球，第 i 个球需要放在区间 [L,R] 内的整数位置上。
但每个整数位置上至多能放一个球。
如果可以做到，输出 Yes，否则输出 No
https://atcoder.jp/contests/keyence2020/tasks/keyence2020_d

输入 n(≤18) 和两个长为 n 的数组 a b，元素范围在 [1,50]。
a[i] 和 b[i] 表示第 i 张牌的正面数字和背面数字。
初始所有牌正面朝上。
每次操作你可以交换第 i 和 i+1 张牌的位置，同时翻转这两张牌。
输出让看到的数字从左往右是递增（允许相等）所需要的最小操作次数。
如果无法做到，输出 -1。
https://atcoder.jp/contests/arc091/tasks/arc091_c

输入 n a b (≤3e5)。
构造一个 1~n 的排列，其 LIS 的长度为 a，LDS 的长度为 b。
如果不存在这样的排列，输出 -1，否则输出任意一个满足要求的排列。
注：LIS 指最长上升子序列，LDS 指最长下降子序列。
https://atcoder.jp/contests/arc125/tasks/arc125_c

输入 n k (k≤n≤2e5) 和一个长为 k 的严格递增数组 a，元素范围 [1,n]。
输出一个 1~n 的排列 p，使得 a 是 p 的一个 LIS。
如果有多个这样的 p，输出字典序最小的那个。
注：LIS 指最长上升子序列。
https://atcoder.jp/contests/arc147/tasks/arc147_b

输入 n(≤400) 和一个 1~n 的排列 p，下标从 1 开始。
你有两种操作：
操作 "A i" 可以交换 p[i] 和 p[i+1]；
操作 "B i" 可以交换 p[i] 和 p[i+2]。

你需要让 p 变为递增的。
最小化操作 A 的次数，同时总操作次数不能超过 1e5。
输出总操作次数，以及具体的操作内容，详见样例。
如果有多个符合要求的方案，输出任意一种。
保证存在这样的操作方案。
https://atcoder.jp/contests/arc132/tasks/arc132_c

输入 n(≤500) d(≤5) 和长为 n 的数组 a。
a 原本是一个 1~n 的排列 p，不过有些数字被替换成了 -1。
你需要还原 p，使得 abs(p[i]-i) ≤ d 对每个 i 都成立。
输出有多少个这样的 p，模 998244353。
https://atcoder.jp/contests/arc144/tasks/arc144_c

输入 n 和 k (k<n≤3e5)。
请构造一个字典序最小的 1~n 的排列 p（下标从 1 开始），使得 abs(p[i]-i)≥k 对每个 i 都成立。
如果无法构造，输出 -1。否则输出 p。
https://atcoder.jp/contests/arc140/tasks/arc140_c

输入 n 和 x (x≤n≤2e5)。
你需要构造一个 1~n 的排列 p，其中第一项为 x。
p 可以生成一个长为 n-1 的数组 a，使得 a[i]=abs(p[i]-p[i+1])。
通过构造合适的 p，最大化 a 的 LIS（最长严格递增子序列）的长度。
输出 p。
https://atcoder.jp/contests/abc059/tasks/arc072_a

输入 n (2≤n≤1e5) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。
每次操作你可以把一个 a[i] 加一或减一。
如果要让 a 的所有相邻前缀和的乘积都小于 0，至少需要操作多少次？
https://atcoder.jp/contests/abc102/tasks/arc100_b

输入 n (4≤n≤1e5) 和一个长为 n 的数组 a (1≤a[i]≤1e9)。
将 a 分割成 4 个非空连续子数组，计算这 4 个子数组的元素和。
你需要最小化这 4 个和中的最大值与最小值的差。
输出这个最小值。
https://atcoder.jp/contests/abc066/tasks/arc077_b

输入 n(≤1e5) 和一个长为 n+1 的数组 a，元素范围 [1,n]，且 [1,n] 的每个数都在 a 中。
对每个 [1,n+1] 的 k，输出有多少个长为 k 的不同子序列，模 1e9+7。
注：下标不同但内容相同的子序列，算相同的子序列。
https://atcoder.jp/contests/arc116/tasks/arc116_d

输入 n(≤5000) 和 m (≤5000)。
你需要计算满足如下要求的数组个数：
1. 包含 n 个非负整数；
2. 所有数的和为 m；
3. 所有数的异或和为 0。
输出这样的数组个数，模 998244353。
https://atcoder.jp/contests/arc136/tasks/arc136_b

输入 n(3≤n≤5000) 和两个长为 n 的数组 a b，元素范围在 [1,5000]。
你可以对数组 a 执行如下操作任意多次：
选择三个相邻的数 a[i] a[i+1] a[i+2]，设这三个数为 x y z，更新 a[i]=z a[i+1]=x a[i+2]=y。
如果可以把 a 变成 b，输出 Yes，否则输出 No。
https://atcoder.jp/contests/arc097/tasks/arc097_b

输入 n(≤1e5) m(≤1e5) 和一个 1~n 的排列 p。
然后输入 m 行，每行两个数 x 和 y，表示你可以交换 p[x] 和 p[y]（下标从 1 开始）。
这 m 个操作你可以按任意顺序执行任意多次。
输出你可以让多少个 p[i]=i。
https://atcoder.jp/contests/arc107/tasks/arc107_c

输入 n(≤50) 和 k(≤2n^2)。
然后输入 n^2 个数，表示一个 n*n 的矩阵 a，矩阵元素是 1~n^2 的一个排列。
每次操作，你可以选择下面的两个之一：
1. 选择两列 x 和 y，如果对于每个 i 都有 a[i][x]+a[i][y]≤k，则可以交换这两列。
2. 选择两行 x 和 y，如果对于每个 i 都有 a[x][i]+a[y][i]≤k，则可以交换这两行。
你可以执行任意多次操作。
输出你能得到的不同矩阵个数，模 998244353 的结果。
https://atcoder.jp/contests/arc119/tasks/arc119_b

输入 n(≤5e5) 和两个长为 n 的 01 字符串 s 和 t。
每次操作，你可以把 s 中形如 011..1 或 11..10 的子串的最左最右两个字符交换。
输出把 s 变成 t 最小操作次数，如果无法做到输出 -1。
https://atcoder.jp/contests/arc133/tasks/arc133_c

输入 n m k (≤2e5) 和长度分别为 n 和 m 的数组 a 和 b，元素范围 [0,k-1]。
构造一个 n 行 m 列，元素范围在 [0,k-1] 的矩阵，使得第 i 行的元素和 % k = a[i]，第 j 列的元素和 % k = b[j]。
你只需要输出这个矩阵的元素和的最大值。
如果这个矩阵不存在，输出 -1。
https://atcoder.jp/contests/arc120/tasks/arc120_c

输入 n(≤2e5) 和两个长为 n 的数组 a b，元素范围在 [0,1e9]。
每次操作你可以选择 a 中的两个相邻数字，设 x=a[i], y=a[i+1]，更新 a[i]=y+1, a[i+1]=x-1。
输出把 a 变成 b 的最小操作次数，如果无法做到则输出 -1。
https://atcoder.jp/contests/abc178/tasks/abc178_f

输入 n(≤2e5) 和两个长为 n 的非降数组 a b，元素范围在 [1,n]。
如果可以重排 b，使得 a[i] != b[i] 对每个 i 都成立，则输出 Yes 和重排后的 b，否则输出 No。
https://atcoder.jp/contests/abc106/tasks/abc106_d

输入 n(≤500) m(≤2e5) q(≤1e5)。
然后输入 m 个在 [1,n] 内的闭区间，即每行输入两个数表示闭区间 [L,R]。
然后输入 q 个询问，每个询问也是输入两个数表示闭区间 [p,q]。
对每个询问，输出在 [p,q] 内的完整闭区间的个数。
https://atcoder.jp/contests/abc175/tasks/abc175_e

输入 n m (1≤n,m≤3000) k(≤min(2e5,r*c))，表示一个 n*m 的网格，和网格中的 k 个物品。
接下来 k 行，每行三个数 x y v(≤1e9) 表示物品的行号、列号和价值（行列号从 1 开始）。
每个网格至多有一个物品。

你从 (1,1) 出发走到 (n,m)，每步只能向下或向右。
经过物品时，你可以选或不选，且每行至多可以选三个物品。
输出你选到的物品的价值和的最大值。
https://atcoder.jp/contests/abc210/tasks/abc210_d

输入 n m (2≤n,m≤1000) c(≤1e9) 和一个 n 行 m 列的矩阵 a，元素范围 [1,1e9]。
对于两个不同位置 (i,j) 和 (i',j')，输出 a[i][j] + a[i'][j'] + c*(|i-i'|+|j-j'|) 的最小值。
https://atcoder.jp/contests/abc203/tasks/abc203_d

输入 n k (1≤k≤n≤800) 和一个 n*n 的矩阵，元素范围 [0,1e9]。
定义 k*k 子矩阵的中位数为子矩阵的第 floor(k*k/2)+1 大的数。
输出中位数的最小值。
注：「第 x 大」中的 x 从 1 开始。
https://atcoder.jp/contests/abc210/tasks/abc210_e

输入 n(≤1e9) 和 m(≤1e5)，表示一个 n 个点，0 条边的图（节点编号从 0 开始），以及 m 个操作。
每个操作输入两个数 a(1≤a≤n-1) 和 c(≤1e9)，表示你可以花费 c，任意选择一个 [0,n-1] 内的数字 x，把 x 和 (x+a)%n 连边。
这 m 个操作，每个都可以执行任意多次，可以按任意顺序执行。
输出让图连通需要的最小花费。
如果无法做到，输出 -1。
https://atcoder.jp/contests/abc130/tasks/abc130_e

输入 n(≤2000) 和 m(≤2000)，长度分别为 n 和 m 的数组 a 和 b，元素范围 [1,1e5]。
从 a 和 b 中分别选出一个子序列（允许为空），要求这两个子序列相同。
输出有多少种不同的选法，模 1e9+7。
注意：选出的子序列不同，当且仅当下标不同（即使子序列的元素是相同的，也算不同）。
https://atcoder.jp/contests/abc140/tasks/abc140_e

输入 n(≤1e5) 和一个 1~n 的排列 p。
输出 p 中所有长度至少为 2 的子数组的第二大元素的和。
https://atcoder.jp/contests/abc185/tasks/abc185_e

输入 n(≤1000) 和 m(≤1000)，长度分别为 n 和 m 的数组 a 和 b，元素范围 [1,1e9]。
从 a 中移除若干元素，得到一个子序列 a'；从 b 中移除若干元素，得到一个子序列 b'。
要求 a' 和 b' 的长度相同。
输出 (a和b总共移除的元素个数) + (a'[i]≠b'[i]的i的个数) 的最小值。
https://atcoder.jp/contests/abc168/tasks/abc168_e

输入 n(≤2e5) 和 n 个点 (xi, yi)，范围 [-1e18,1e18]。
你需要从这 n 个点中选出一个非空子集，满足子集中任意两点都有 xi*xj+yi*yj ≠ 0。
子集的大小可以为 1。
输出有多少种不同的选法，模 1e9+7。

注意：可能有重复的点。
https://atcoder.jp/contests/abc162/tasks/abc162_f

本题是力扣 198. 打家劫舍 的变形题。

输入 n (2≤n≤2e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)。
数组 a 就是 198 题的房屋存放金额。
在本题中，你必须恰好偷 floor(n/2) 个房子。
输出你能偷窃到的最高金额。

你能做到 O(1) 空间吗？
https://atcoder.jp/contests/abc171/tasks/abc171_f

输入 k(≤1e6) 和一个长度不超过 1e6 的字符串 s，由小写字母组成。
你需要在 s 中插入恰好 k 个小写字母。
输出你能得到的字符串的个数，模 1e9+7。
https://atcoder.jp/contests/jsc2021/tasks/jsc2021_f

输入 n m q (≤2e5)，初始你有长为 n 的数组 a，长为 m 的数组 b，元素值都为 0，下标从 1 开始。
然后输入 q 个询问，每个询问形如 t x y (1≤y≤1e8)。
t=1，表示把 a[x]=y；t=2，表示把 b[x]=y。
每次修改后，输出 ∑∑max(a[i],b[j])，这里 i 取遍 [1,n]，j 取遍 [1,m]。
https://atcoder.jp/contests/abc201/tasks/abc201_e

输入 n(≤2e5) 和一棵有边权的树的 n-1 条边，节点编号从 1 开始，边权范围 [0,2^60)。
定义 xor(i,j) 表示从 i 到 j 的简单路径上的边权的异或和。
累加所有满足 1≤i<j≤n 的 xor(i,j)，对结果模 1e9+7 后输出。
https://atcoder.jp/contests/abl/tasks/abl_e

输入 n(≤2e5) 和 q(≤2e5)。
初始有一个长为 n 的字符串 s，所有字符都是 1，s 的下标从 1 开始。
然后输入 q 个替换操作，每个操作输入 L,R (1≤L≤R≤n) 和 d (1≤d≤9)。
你需要把 s 的 [L,R] 内的所有字符替换为 d。
对每个操作，把替换后的 s 看成一个十进制数，输出这个数模 998244353 的结果。
https://atcoder.jp/contests/abc173/tasks/abc173_f

输入 n (2≤n≤2e5) 和一棵树的 n-1 条边（节点编号从 1 开始）。
定义 f(L,R) 表示用节点编号在 [L,R] 内的点组成的连通块的个数（边的两个端点必须都在 [L,R] 内）。
输出满足 1≤L≤R≤n 的所有 f(L,R) 的和。
https://atcoder.jp/contests/abc165/tasks/abc165_f

输入 n (2≤n≤2e5) 和长为 n 的数组 a (1≤a[i]≤1e9)，表示每个节点的点权。
然后输入一棵树的 n-1 条边（节点编号从 1 开始）。
输出 n 个数，第 i 个数为从节点 1 到节点 i 的路径上点权的 LIS 长度。

注：LIS 指最长严格递增子序列。
https://atcoder.jp/contests/abc252/tasks/abc252_f

输入 n (2≤n≤2e5) 和 L(≤1e15)，长为 n 的数组 a (1≤a[i]≤1e9, sum(a)≤L)。
有一根长为 L 的面包，需要分给 n 个小孩，每个小孩需要长度恰好为 a[i] 的面包。
对于任意一根长为 k 的面包，你可以切成两段，要求每段长度都为整数，切的花费为 k。
输出最小花费。
https://atcoder.jp/contests/abc255/tasks/abc255_e

输入 n (2≤n≤1e5) 和 m(≤10)，长为 n-1 的数组 s 和长为 m 的严格递增数组 x，元素值范围在 [-1e9,1e9]。
数组 x 中的元素叫做幸运数。
对于一个长为 n 的序列 a，如果所有相邻元素满足 a[i]+a[i+1]=s[i]，则称为一个好序列。
输出好序列中最多能有多少个数是幸运数（重复数字也算，见样例）。
https://atcoder.jp/contests/abc169/tasks/abc169_e

输入 n (2≤n≤2e5) 和 n 个区间的左右端点，区间范围在 [1,1e9]。
每个区间内选一个整数，然后计算这 n 个整数的中位数。你能得到多少个不同的中位数？
注：偶数长度的中位数是中间两个数的平均值（没有下取整）。
https://atcoder.jp/contests/abc251/tasks/abc251_e

输入 n (2≤n≤3e5) 和长为 n 的数组 a (1≤a[i]≤1e9)，下标从 1 开始。
有 n 只动物围成一圈，你可以花费 a[i] 喂食动物 i 和 i+1。特别地，你可以花费 a[n] 喂食动物 n 和 1。
输出喂食所有动物需要的最小花费。每只动物可以重复喂食。
https://atcoder.jp/contests/abc237/tasks/abc237_f

输入 n (3≤n≤1000) 和 m (3≤m≤10)。
输出有多少个满足如下条件的数组：
1. 数组长度为 n；
2. 数组元素范围在 [1,m]；
3. 数组的 LIS 的长度恰好等于 3。
对答案模 998244353。

注：LIS 指最长严格上升子序列。
https://atcoder.jp/contests/abc250/tasks/abc250_e

输入 n(≤2e5) 和两个长为 n 的数组 a 和 b，元素范围在 [1,1e9]。
然后输入 q(≤2e5) 表示 q 个询问，每个询问输入两个数 x 和 y，范围在 [1,n]。
对每个询问，设 a 的前 x 个元素去重得到集合 A，b 的前 y 个元素去重得到集合 B，如果 A = B，输出 "Yes"，否则输出 "No"。
https://atcoder.jp/contests/abc221/tasks/abc221_e

【更新通知】
从今天开始，带你们刷 AtCoder 啦！难度分大概是之前的 -400

输入 n(≤3e5) 和长为 n 的数组 a (1≤a[i]≤1e9)。
输出有多少个 a 的长度至少为 2 的子序列，满足子序列的第一项 ≤ 子序列的最后一项。
由于答案很大，输出答案模 998244353 的结果。

注：子序列不要求连续。
https://codeforces.com/problemset/problem/1208/E

输入 n(≤1e6) 和 w(≤1e6)，表示一个 n 行 w 列的表格。
然后输入 n 个数组，第 i 个数组放在第 i 行中。
输入的格式为：第一个数字表示数组的长度 m(≤w)，然后输入一个长为 m 的数组，元素范围 [-1e9,1e9]。
保证所有数组的长度之和不超过 1e6。

你可以滑动任意一行的整个数组。
对表格的每一列，输出这一列的元素和的最大值。
注意：每一列是单独计算的，不同列可以有不同的滑动方案。
https://codeforces.com/problemset/problem/1420/D

输入 n, k (1≤k≤n≤3e5) 和 n 个闭区间，区间的范围在 [1,1e9]。
你需要从 n 个区间中选择 k 个区间，且这 k 个区间的交集不为空。
输出方案数模 998244353 的结果。
https://codeforces.com/problemset/problem/767/C

输入 n(3≤n≤1e6)，表示一颗有 n 个节点的有根树，节点编号从 1 开始。
每行输入两个数，表示当前节点的父节点编号（如果是 0 表示当前节点是根节点），以及节点的点权，范围在 [-100,100]。
例如节点 1 的父节点为 2，则表示一条 2->1 的边。

你需要删除两条边，将这棵树分成三个连通块，且每个连通块的点权和相等。
假设删除的边是 a->b 和 c->d，你需要输出 b 和 d。如果有多种方案，输出任意一种。
如果无法做到，输出 -1。
https://codeforces.com/problemset/problem/1407/D

输入 n(≤3e5) 和一个长为 n 的数组 h (1≤h[i]≤1e9)。
满足如下三个条件之一，就可以从 i 跳到 j (i<j)：
1. i+1=j
2. max(h[i+1],...,h[j-1]) < min(h[i],h[j])
3. min(h[i+1],...,h[j-1]) > max(h[i],h[j])
输出从 1 跳到 n 最少需要多少步。

相似题目：LC2297 https://leetcode.cn/problems/jump-game-viii/
https://codeforces.com/problemset/problem/1286/A

输入 n(≤100) 和一个长为 n 的数组 p，p 原本是一个 1~n 的排列，但是有些数字丢失了，丢失的数字用 0 表示。
你需要还原 p，使得 p 中相邻元素奇偶性不同的对数最少。输出这个最小值。
xhttps://codeforces.com/problemset/problem/1651/D

输入 n(≤2e5) 和 n 个二维平面上的互不相同的整点，坐标范围 [1,2e5]。
对每个整点，输出离它曼哈顿距离最近的，且不在输入中的整点。
两点的曼哈顿距离=横坐标之差的绝对值+纵坐标之差的绝对值。
https://codeforces.com/contest/988/problem/F

输入正整数 dst(≤2000), n(≤(dst+1)/2) 和 m(≤2000)。
然后输入 n 个互不相交的下雨区间，左右端点满足 0≤L<R≤dst。
然后输入 m 行，每行两个数表示雨伞的位置 x[i](≤dst) 和重量 w[i](≤1e5)。

你需要从 0 出发走到 dst。在下雨区间内移动必须打伞（区间端点处不算下雨）。
你可以中途换伞。
带着伞移动时，每走一单位长度，消耗的耐力等于伞的重量。
你可以丢掉伞，空手移动时消耗的耐力为零。
输出到达 dst 至少需要消耗多少耐力。如果无法到达 dst，输出 -1。

进阶：请写一个和坐标范围无关的代码，即使坐标范围达到 1e9 也可以通过。
https://codeforces.com/problemset/problem/38/E

输入 n(≤3000)，表示在一维数轴上有 n 颗大小忽略不计的弹珠。
然后输入 n 对数字，每对数字表示这颗弹珠在数轴上的位置 xi，以及把这颗弹珠固定在 xi 上的花费 ci，数据范围均在 [-1e9,1e9] 之间，且 xi 互不相同。注意 ci 可以为负。

选择若干弹珠固定后，所有未固定的弹珠向左滚动，直到碰到固定住的弹珠。
总花费 = 固定弹珠的花费之和 + 所有未固定的弹珠的滚动距离之和。
输出总花费的最小值。
注：根据题意，最左边的弹珠一定要固定。
https://codeforces.com/problemset/problem/862/E

输入 n, m (1≤n≤m≤1e5), q(≤1e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)，长为 m 的数组 b (-1e9≤a[i]≤1e9)，下标从 1 开始。
定义 f(j) = abs(c1-c2+c3-c4...cn), 其中 ci = a[i]-b[i+j]。
首先，输出 f(0), f(1), ..., f(m-n) 的最小值。
然后输入 q 个询问，每个询问输入 l, r (1≤l≤r≤n), x(-1e9≤x≤1e9)，表示把 a[l], a[l+1], ..., a[r] 都加上 x，之后输出 f(0), f(1), ..., f(m-n) 的最小值。+x 的影响是永久的。
https://codeforces.com/problemset/problem/754/D

输入 n, k (1≤k≤n≤3e5) 和 n 个闭区间，区间左右端点在 [-1e9,1e9] 内，区间的编号从 1 开始。
请你选择 k 个区间，使得这 k 个区间的交集的大小尽量大（只考虑整数），输出这个最大值，以及对应的区间的编号。

思考题：如果改成并集呢？
https://codeforces.com/problemset/problem/811/C

输入 n(≤5000) 和一个长为 n 的数组 a (0≤a[i]≤5000)。
你需要从 a 中选取若干个互不相交的子数组，且对于每个子数组 b，b 中的元素不会出现在 b 外面。
对每个子数组去重，求异或和，然后把所有异或和相加，输出相加后的最大值。

注：子数组是连续的。
注：你不需要把每个 a[i] 都选上，见样例二。
https://codeforces.com/problemset/problem/863/E

输入 n(≤2e5) 和 n 个闭区间，区间左右端点在 [0,1e9] 内，区间的编号从 1 开始。
你需要从中删除一个区间，使得删除前后，所有区间的并集不变（只考虑整数）。
如果不存在这样的区间，输出 -1；否则输出该区间的编号。
https://codeforces.com/problemset/problem/276/D

输入 L 和 R (1≤L≤R≤1e18)。
输出区间 [L,R] 内任意两个数的异或的最大值。

思考题：如果还要求异或不超过某个 limit 呢？
https://codeforces.com/problemset/problem/965/D

输入 w(≤1e5) L(<w) 和一个长为 w-1 的数组 a (0≤a[i]≤1e4，下标从 1 开始)。
有一条宽为 w 的河，青蛙们在位置 0 处，位置 i 处有 a[i] 个石头，位置 w 为河对岸。
青蛙单次跳跃距离不超过 L。每个石头只能被一只青蛙用一次。
输出最多有多少只青蛙能过河。

相似题目：蓝桥杯2022年第十三届省赛真题-青蛙过河
https://www.dotcpp.com/oj/problem2667.html
https://codeforces.com/problemset/problem/1178/E

输入一个长度不超过 1e6 的字符串 s，仅包含 a b c，且相邻字符不同。
你需要找到一个 s 的回文子序列 t，且 t 的长度至少是 s 长度的一半（下取整）。
输出任意一个符合要求的 t。
注意子序列不要求连续。
https://codeforces.com/problemset/problem/558/C

输入 n(≤1e5) 和一个长为 n 的数组 a (1≤a[i]≤1e5)。
每次操作你可以将某个 a[i] 乘二或除二（下取整）。
输出至少需要多少次操作，可以让 a 的所有数都相同。

你能做到 O(nlogU) 的时间复杂度吗？ U=max(a)
https://codeforces.com/problemset/problem/292/E

输入 n(≤1e5) 和 m (≤1e5)，两个长度都为 n 的数组 a 和 b（元素范围在 [-1e9,1e9] 内，下标从 1 开始）。
然后输入 m 个操作：
操作 1 形如 1 x y k，表示把 a 的区间 [x,x+k-1] 的元素拷贝到 b 的区间 [y,y+k-1] 上（输入保证下标不越界）。
操作 2 形如 2 x，输出 b[x]。

思考题：双向 copy 怎么做？  @Hush@Aging
https://codeforces.com/problemset/problem/274/B

输入 n(≤1e5)，表示一棵有 n 个节点的树。
然后输入 n-1 条边：这条边所连接的两点的编号（从 1 开始）。
最后输入 n 个数，表示每个节点的值 a[i](-1e9≤a[i]≤1e9)。

每次操作，你可以选择一个包含节点 1 的连通块，把所有点的值都 +1 或都 -1。
输出把树上所有节点的值都变为 0 的最少操作次数。
https://codeforces.com/problemset/problem/1213/G

输入 n(≤2e5) 和 m(≤2e5)，表示一棵有 n 个节点的树，和 m 个询问。
然后输入 n-1 条边：这条边所连接的两点的编号（从 1 开始），以及边权(1≤边权≤2e5)。
最后输入 m 个询问 q[i](1≤q[i]≤2e5)，你需要对每个询问，输出树上有多少条路径，要求路径至少有两个节点且无重复节点，且路径上的最大边权不超过 q[i]。
注意 a->b 和 b->a 的路径只统计一次。

相关题目：昨天周赛第四题 https://leetcode.cn/problems/number-of-good-paths/
https://codeforces.com/problemset/problem/522/D

输入 n(≤5e5) 和 m(≤5e5)；然后输入一个长为 n 的数组 a(-1e9≤a[i]≤1e9)，数组下标从 1 开始；然后输入 m 个询问，每个询问表示一个数组 a 内的闭区间 [L,R] (1≤L≤R≤n)。

对每个询问，输出区间内的相同元素下标之间的最小差值。如果区间内不存在相同元素，输出 -1。

相似题目：https://www.luogu.com.cn/problem/P1972
https://codeforces.com/problemset/problem/555/B

输入 n(2≤n≤2e5) 和 m(1≤m≤2e5)，然后输入 n 行，每行有两个数，表示一个闭区间（1≤L≤R≤1e18），然后输入一个长为 m 的数组 a (1≤a[i]≤1e18)。输入保证区间之间没有交集，且上一个区间的右端点小于下一个区间的左端点。

你有 m 座桥，每座桥的长为 a[i]，你需要选择 n-1 座桥连接所有相邻的区间。
要求桥的两个端点分别落在这两个闭区间内（这两个端点的差等于桥长）。

如果无法做到，输出 No；否则输出 Yes，然后按顺序输出这 n-1 座桥的编号（编号从 1 开始），输出的第一座桥连接第一个区间和第二个区间，输出的第二座桥连接第二个区间和第三个区间，依此类推。

思考：如果不要求连接的两个区间相邻，你能否连通所有区间？

本题算作区间与点的最大匹配/覆盖问题
类似的还有 https://www.luogu.com.cn/problem/P2887
https://codeforces.com/problemset/problem/1619/E

输入 t (≤1e4) 表示 t 组数据，每组数据输入 n(≤2e5) 和一个长为 n 的数组 a (0≤a[i]≤n)。所有数据的 n 之和不超过 2e5。
每次操作，你可以把数组中的一个数加一。
定义 mex(a) 表示不在 a 中的最小非负整数。
定义 f(i) 表示使 mex(a) = i 的最小操作次数。如果无法做到，则 f(i) = -1。
输出 n+1 个数：f(0), f(1), ..., f(n)。
https://codeforces.com/problemset/problem/377/A

输入 n(≤500) m(≤500) k 和一个 n 行 m 列的网格图，'#' 表示墙，'.' 表示平地。
保证所有 '.' 可以互相到达（四方向连通）。保证 k 小于 '.' 的个数。
你需要把恰好 k 个 '.' 修改成 'X'，使得剩余的所有 '.' 仍然是可以互相到达的。
输出修改后的网格图。
https://codeforces.com/problemset/problem/1395/C

输入 n(≤200) 和 m(≤200)，长为 n 的数组 a(0≤a[i]<512) 和长为 m 的数组 b(0≤b[i]<512)。
对于每个 a[i]，你可以选择任意一个 b[j]，组成 c[i]=a[i]&b[j]。
输出 c 数组的所有元素按位或的最小值。

思考：如果值域是 1e9 要怎么做？
https://codeforces.com/problemset/problem/827/B

输入 n 和 k (2≤k<n≤2e5)。
构造一棵有 n 个节点的树，其中度数为 1 的点恰好有 k 个，且这些点之间的最大距离最小。
输出这个最小值，和这棵树的 n-1 条边。节点编号从 1 开始。
如果有多种构造方案，输出任意一种。

注：一个点的度数等于与该点相连的边的数目。
https://codeforces.com/problemset/problem/837/D

输入 n k (1≤k≤n≤200) 和一个长为 n 的数组 a (1≤a[i]≤1e18)。
从 a 中选择一个长为 k 的子序列，设这 k 个数的乘积为 m。
输出 m 的末尾 0 的个数的最大值。

子序列不一定连续。
http://codeforces.com/problemset/problem/543/A

输入 n (1≤n≤500) m (1≤m≤500) b (0≤b≤500) mod (1≤mod≤1e9+7) 和一个长为 n 的数组 a (0≤a[i]≤500)。

你接手了一个有很多祖传代码的老项目，该项目由 n 个程序员开发，目前有 m 行代码。
已知第 i 个程序员在一行代码中会产生 a[i] 个 bug。
你尚不知道每个程序员分别写了多少行代码，于是你思考：有多少种方案，能使项目的 bug 数量不超过 b 个？由于答案很大，你需要输出答案模 mod 的结果。

注意：两种方案不同，当且仅当某个程序员编写的行数不同。
可能有程序员一行代码都不写。
https://codeforces.com/problemset/problem/1494/C

输入 t (≤1000) 表示 t 组数据，每组数据输入 n (≤2e5) m (≤2e5)，长为 n 的严格递增数组 a (-1e9≤a[i]≤1e9) 和长为 m 的严格递增数组 b (-1e9≤b[i]≤1e9)。a 和 b 中均不包含 0。所有数据的 n 之和、m 之和均不超过 2e5。

你在玩一个一维推箱子的游戏，你的初始位置为 0，箱子的位置由数组 a 表示，特殊位置由数组 b 表示。
你可以同时推动多个相邻的箱子。
你不能穿过箱子。
你不能拉箱子。
对于每组数据，输出最多可以让多少个箱子在特殊位置上。
注意可能有的箱子一开始就在特殊位置上。

你能做到线性时间复杂度，且除去输入的空间为常数吗？
https://codeforces.com/problemset/problem/1197/D

输入 n (1≤n≤3e5) m (1≤m≤10) k (1≤k≤1e9) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。
定义数组 b 的价值为 sum(b) - k * ceil(len(b) / m)。
空数组的价值为 0。
输出 a 的所有子数组的最大价值。
https://codeforces.com/problemset/problem/1400/D

输入 t (≤100) 表示 t 组数据，每组数据输入 n (4≤n≤3000) 和一个长为 n 的数组 a (1≤a[i]≤n)，下标从 1 开始。所有数据的 n 之和 ≤3000。
对每组数据，输出满足 1≤i<j<k<l≤n 且 a[i]=a[k] 且 a[j]=a[l] 的四元组 (i,j,k,l) 的数量。

相似题目 https://codeforces.com/contest/1677/problem/A
https://codeforces.com/problemset/problem/896/A

用编程语言声明字符串序列 f（\" 表示字符串中的引号）：
f[0] = "What are you doing at the end of the world? Are you busy? Will you save us?"
f[i] = "What are you doing while sending \"" + f[i-1] + "\"? Are you busy? Will you send \"" + f[i-1] + "\"?"

输入 t (≤10) 表示 t 组数据，每组数据输入 n (0≤n≤1e5) 和 k (1≤k≤1e18)。
对每组数据，输出 f[n][k-1]，如果 f[n] 的长度不足 k，则输出一个英文句点 '.'。

题目背景：《末日三问》
https://codeforces.com/problemset/problem/371/D

输入 n (≤2e5) 和一个长为 n 的数组 a (1≤a[i]≤1e9)，表示有 n 个盛水的容器，从上到下串起来（如下图），从上到下第 i 个容器的容量为 a[i]。初始时，所有容器都是空的。

然后输入 m (≤2e5) 个询问，每个询问的格式如下（i 从 1 开始）：
1 i x，表示往第 i 个容器倒 x (≤1e9) 单位的水。溢出的水会流到下一个容器，下一个容器溢出的水会流到下下一个容器，……，最后一个容器溢出的水会流到地板上。
2 i，输出第 i 个容器有多少单位的水。














https://codeforces.com/contest/729/problem/D

输入 n (≤2e5) a b (1≤a,b≤n) k (0≤k≤n-1) 和一个长为 n 的字符串 s，只包含 0 和 1，且恰好有 k 个 1。

有 n 个格子排成一行，里面有 a 艘船，每艘船占据连续 b 个格子。两艘船不会占据同一个格子。
现在已经为你揭露了 k 个没有船的格子，用字符串 s 中的 1 表示（0 表示尚未揭露的格子）。
你可以发射炮弹，一次可以揭露一个格子。
输出保证射中一艘船，至少需要发射的次数和具体射击的格子编号（从 1 开始）。如果发射方案有多种，输出任意一种。
保证答案存在。
https://codeforces.com/problemset/problem/484/A

输入 t (t≤1e4) 表示 t 组数据，每组数据输入两个数 L 和 R (0≤L≤R≤1e18)。

对每组数据，输出在区间 [L,R] 内的二进制中的 1 的个数最多的那个数字，如果有多个这样的数字，输出最小的。

思考：如果让你找的是 0 的个数最多的那个数字呢？（前导零不计）
https://codeforces.com/problemset/problem/1168/A

输入 n (1≤n≤3e5)、m (1≤m≤3e5) 和一个长为 n 的数组 a，元素值在 [0,m-1] 内。

每次操作，你可以选择 a 中的某些数，把每个数 x 改成 (x+1)%m。

输出使 a 变成单调非降的最少操作次数。

反向思考：给定 n 和 m，如何构造出一个让最少操作次数最大的数组 a？
https://codeforces.com/problemset/problem/1207/D

输入 n (≤3e5) 和一个 pair 数组 p，即 p1=(a1,b1), p2=(a2,b2), ..., pn=(an,bn)，其中 ai 和 bi 均在 [1,n] 内。

定义一个 1~n 的下标排列是好的，当且仅当 p 按照该下标排列重排后，{ai} 序列和 {bi} 序列均不是单调非降的。

输出好的下标排列的个数。
https://codeforces.com/problemset/problem/933/A

输入 n (≤2000) 和一个长为 n 的数组 a，元素值只有 1 和 2。
你可以翻转 a 的一个区间（该操作执行至多一次）。
输出你能得到的最长非降子序列的长度。
子序列不要求连续。

进阶：你能做到 O(n) 吗？
扩展：元素范围在 [0,9] 的情况 http://acm.hdu.edu.cn/showproblem.php?pid=6357
https://codeforces.com/problemset/problem/1537/E1
https://codeforces.com/problemset/problem/1537/E2

本题分为简单版本和困难版本，在困难版本中，n 和 k 不超过 5e5。

输入 n (≤5000) 和 k (≤5000)，以及一个长为 n 的字符串 s，由小写字母组成。

有如下两种操作，每种操作你都可以执行任意多次：
1. 删除 s 的最后一个字符；
2. 将 s 复制一份拼在后面，即 s = s + s。

输出你能得到的所有长为 k 的字符串中，字典序最小的字符串。
https://codeforces.com/problemset/problem/1551/D1
https://codeforces.com/problemset/problem/1551/D2

本题分为简单版本和困难版本，在困难版本中，你需要额外输出具体的方案。

输入 t (≤10) 表示有 t 组数据。
每组数据输入 n (≤100)、m (m≤100) 和 k (0≤k≤n*m/2)，保证 n*m 是偶数。

请你在一个 n 行 m 列的网格中，放置 n*m/2 个 1*2 大小的骨牌，要求恰好有 k 个是横着放的，其余是竖着放的，且恰好铺满这一 n*m 的网格。

如果存在满足要求的铺设方案，输出 YES，否则输出 NO。
对于困难版本，如果答案存在，你需要额外输出 n 个长为 m 的由小写字母组成的字符串，表示你铺设的骨牌（多种方案输出任意一种）。要求：两个相邻的单元格拥有相同的字母，表明这两个单元格由同一个骨牌覆盖。具体输出样例见困难版本题目。
https://codeforces.com/problemset/problem/1611/F

输入 t (≤1e4) 表示有 t 组数据。
每组数据输入 n (≤2e5)、s (0≤s≤1e9) 和一个长为 n 的数组 a (-1e9≤a[i]≤1e9)。
所有数据的 n 之和不超过 2e5。

请你在 a 中找到一个最长的连续子数组 b，满足 b 的每个前缀和都 ≥ -s（注意是 -s）。
如果存在这样的 b，输出 b 的左右边界在 a 中的下标 l 和 r（下标从 1 开始，如果有多个答案，输出任意一种）。
如果不存在这样的 b，输出 -1。

思考：如果 s<0 要怎么做？@Zakl
https://codeforces.com/problemset/problem/691/C

上场周赛出了一道【易错题】（周赛第二题），所以今天我也找了一道【易错题】，带大家针对训练一下。

输入一个长度不超过 1e6 的字符串 x，表示一个大于 0 的小数（可能有前导零）。
输出 x 的科学计数法表示（格式为 aEb），要求：
① 1≤a<10，如果 a 是整数，不要输出小数点。
② b 必须是整数，如果 b=0，那么你只需要输出 a。
https://codeforces.com/problemset/problem/482/B

输入 n (n≤1e5) 和 m (m≤1e5)，以及 m 个约束，每个约束包含三个数 l r q (1≤l≤r≤n, 0≤q<2^30)。

请你构造一个长为 n 的数组 a，对于每个约束，都满足 a[l] AND a[l+1] AND ... AND a[r] = q。
这里 AND 表示按位与，数组的下标从 1 开始。
如果无法构造，输出 NO；否则输出 YES 和任意一个符合要求的数组 a。

https://codeforces.com/problemset/problem/1108/E1
https://codeforces.com/problemset/problem/1108/E2

本题分为简单版本和困难版本，唯一的区别是，在困难版本中 n≤1e5。

输入 n (n≤300) 和 m (m≤300)，以及长度为 n 的数组 a，元素值范围在 [-1e6,1e6]，数组的下标从 1 开始。
然后输入 m 个闭区间 [l[i],r[i]]。

你可以选择若干个区间（可以一个都不选），对每个区间，将区间内的数字减一（如果一个数字被 k 个区间覆盖，则需要减少 k）。
最大化 max(a) - min(a)。

第一行，输出这个最大值。
第二行，输出你选择了多少个区间。
第三行，按任意顺序输出你选择的区间的编号（从 1 到 m）。
输出任意一种满足要求的方案。

思考：如果 n 和 m 均为 1e5 呢？
https://codeforces.com/problemset/problem/1016/D

输入 n (2≤n≤100) 和 m (2≤m≤100)，以及两个长度分别为 n 和 m 的数组 a 和 b，元素范围均在 [0,1e9]。

请你构造一个 n 行 m 列的矩阵，使得矩阵第 i 行所有数的异或和等于 a[i]，第 j 列所有数的异或和等于 b[j]。
如果不存在这样的矩阵，输出 NO；否则输出 YES 和这个矩阵。

思考：把 XOR 换成 AND / OR 呢？
思考：如果既有 AND 又有 OR 呢？https://atcoder.jp/contests/abc164/tasks/abc164_f
https://codeforces.com/problemset/problem/1066/E

输入 n (≤2e5) 和 m (≤2e5)，以及两个长度分别为 n 和 m 的二进制数 a 和 b。

然后执行如下计算：
ans = 0
while b > 0:
    ans += a & b
    b >>= 1

输出 ans % 998244353 的结果。
https://codeforces.com/problemset/problem/1032/C

输入 n (≤1e5) 和一个长为 n 的数组 a (1≤a[i]≤2e5)。

构造一个长为 n 的数组 b，满足：
1. 1≤b[i]≤5；
2. 如果 a[i]<a[i+1]，则 b[i]<b[i+1]；
3. 如果 a[i]>a[i+1]，则 b[i]>b[i+1]；
4. 如果 a[i]=a[i+1]，则 b[i]≠b[i+1]；
如果不存在这样的 b 则输出 -1，否则输出任意一个满足要求的 b。
https://codeforces.com/problemset/problem/652/C

输入 n 和 m (≤3e5)，一个 1~n 的全排列 p，以及 m 个 pair，元素值均在 [1,n] 中。
称 p 的子数组 b 是合法的，当且仅当对于所有 pair (x,y)，x 和 y 至多有一个在 b 中。
输出有多少个 p 的合法子数组。

进阶：如果 p 有重复元素要怎么做？
https://codeforces.com/problemset/problem/1249/E

输入正整数 n(2≤n≤2e5) 和 c(≤1000)，以及长度均为 n-1 的整数数组 a 和 b，数组元素范围均为 [1,1000]。

走楼梯从 i 层到 i+1 层需要 a[i] 秒。
坐电梯从 i 层到 i+1 层需要 b[i] 秒。
如果你要从某一层开始坐电梯，你需要额外等待 c 秒。

输出从第 1 层走楼梯或者坐电梯到每一层，分别最少需要多少秒。

进阶：做到 O(1) 空间复杂度（不计输入输出）。
https://codeforces.com/problemset/problem/954/C

有一个 x 行 y 列的矩阵，你不知道 x 和 y 的大小，你只知道矩阵中的数字是从 1 开始连续递增的，即：
第一行是 1,2,3,...,y
第二行是 y+1,y+2,y+3,...,2y
……

定义矩阵上的一条路径为：从某一点出发，每一步往四个相邻格子走（不能出界），所走过的数字组成的序列。注意不能停在原地。

现在输入 n(≤2e5) 和一个长为 n 的路径 a (1≤a[i]≤1e9)。
如果存在某个矩阵能走出路径 a，且 x 和 y 均不超过 1e9，则输出 YES 和 x y，否则输出 NO。
如果有多个答案，输出任意一种。

进阶：如果 a[i] ≤ 1e18，其它约束不变，要怎么做？ @七水
http://codeforces.com/problemset/problem/1368/D

输入 n(≤2e5) 和一个长为 n 的整数数组 a (0≤a[i]<2^20)。

每次操作，你可以选择两个数 a[i] 和 a[j]，分别记作 x 和 y，然后更新 a[i] = x AND y, a[j] = x OR y。AND 表示按位与，OR 表示按位或。
你可以执行该操作任意次。
输出 sum(a[i]*a[i]) 的最大值，即 a[0]*a[0] + a[1]*a[1] + ... + a[n-1]*a[n-1] 的最大值。
https://codeforces.com/contest/1217/problem/C

输入 t(t≤1000) 表示 t 组数据。
每组数据输入一个 01 串 s，长度不超过 2e5。所有数据的字符串长度和不超过 2e5。

定义 f(t) 表示子串 t 转换成十进制的值，如 f("011")=3。
求 s 的所有满足 f(t)=len(t) 的非空子串 t 的个数。

注：子串是连续的。

进阶：你能做到 O(1) 额外空间吗？（不含输入）
http://codeforces.com/problemset/problem/1582/E

如果你没有做昨天的题，推荐先做昨天的，再做这道，会简单一些。

输入 t(t≤100) 表示 t 组数据。
每组数据输入 n(1≤n≤1e5) 和长为 n 的整数数组 a (1≤a[i]≤1e9)，所有数据的 n 之和不超过 1e5。

从 a 中选尽可能多的互不相交的子数组，设有 k 个子数组，需满足：
1. 从左到右第一个子数组的长度恰好是 k，第二个的长度恰好是 k-1，……，最后一个的长度恰好是 1；
2. 从左到右第 i 个子数组的元素和严格小于第 i+1 个子数组的元素和。
输出 k 的最大值。

注：子数组是连续的。
https://codeforces.com/problemset/problem/467/C

输入三个正整数 n m k (1≤m*k≤n≤5000)，和一个长为 n 的整数数组 a(0≤a[i]≤1e9)。
从 a 中选择 k 个长度均为 m 且互不相交的子数组，使得这些子数组的元素之和最大，输出这个最大值。
注：子数组是连续的。

进阶：如果 a 是环形数组要怎么做？
https://codeforces.com/problemset/problem/1469/C

输入 t(≤1e4) 表示 t 组数据。
每组数据输入 n(2≤n≤2e5) 和 k(2≤k≤1e8) 和长为 n 的数组 h(0≤h[i]≤1e8)。
所有数据的 n 之和不超过 2e5。

你需要在地面上修一个长为 n 的栅栏，地面的海拔高度用 h 数组表示。
你有 n 块高度均为 k 的木板，你需要用这些木板组成栅栏，要求如下：
1. 相邻两块木板的接触长度至少为 1；
2. 第一块和最后一块木板必须正好与地面接触；
3. 其余木板可以与地面接触，或者位于地面之上，每块木板与地面的距离不能超过 k-1。

如果可以修栅栏，输出 YES，否则输出 NO。
https://codeforces.com/problemset/problem/280/B

输入 n(2≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，a 不含重复元素。
求 a 的所有长度至少为 2 的子数组 b 中，“b 的最大值异或 b 的次大值”的最大值。

如果改成“b 的最大值异或 b 的最小值”的最大值要怎么做？ @Hush
https://codeforces.com/problemset/problem/808/D

输入 n(≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。
你可以选择一个 a[i]，将其移除并插入到 a 的任意位置。
你能否在执行至多一次上述操作的限制下，将 a 划分成左右两部分，且这两部分的元素和相等？
能则输出 YES，不能则输出 NO。
https://codeforces.com/problemset/problem/1060/C

输入 n(≤2000) 和 m(≤2000)，然后输入长为 n 的数组 a 和长为 m 的数组 b，数组元素均为 [1,2000] 内的整数，最后输入一个整数 x(1≤x≤2e9)。
定义矩阵 c[i][j] = a[i]*b[j]。
找到面积最大的子矩阵，其元素和不超过 x，输出这个最大面积（子矩阵的面积=行数*列数）。
如果不存在这样的子矩阵，输出 0。

进阶：有 2000 个询问，每个询问是一个 x（作为原问题的 x），要怎么做？

open question：时间复杂度能否低于平方？

把 * 改成 & 呢？* 和 + 都改成 & 呢？@小羊肖恩
https://codeforces.com/problemset/problem/1043/D

输入 n(≤1e5) 和 m(≤10)，然后输入 m 个长为 n 的排列，元素范围均在 [1,n]。
输出有多少个不同的非空子数组，是每个排列都有的。

注：子数组是连续的。
https://codeforces.com/contest/1519/problem/D

输入 n(≤5000) 和两个长为 n 的整数数组 a 和 b，元素值均在 [1,1e7] 中。
你可以至多反转一次 a 的某个子数组，求 sum(a[i]*b[i]) 的最大值（即最大化 a[0]*b[0]+a[1]*b[1]+...+a[n-1]*b[n-1]）。
https://codeforces.com/contest/175/problem/C

输入 n(≤100) 表示 n 种怪物，然后输入 n 行，每行两个数字表示怪物的数量 (≤1e9)，和怪物的分数(≤1000)。
然后输入 t(≤100) 和一个长为 t 的数组 p，下标从 1 开始，1≤p[1]<p[2]<...<p[t]≤1e12，表示在你累计击败 p[i] 个怪物之后，得分系数将变为 i+1（初始得分系数为 1）。
击败一只怪物的得分 = 怪物的分数 * 当前得分系数。
你可以按照任意顺序打怪，输出击败所有怪物后的最大得分。
https://codeforces.com/problemset/problem/494/A

输入一个长度不超过 1e5 的括号字符串 s，s 中除了 '('，')' 外，还包含至少一个 '#'。
每个 '#' 都可以替换为一个或多个 ')'。问能否将所有的 '#' 都替换掉，得到一个有效括号字符串。
若不能，输出 -1；否则输出 s.count('#') 行，每行一个正整数，表示第 i 个 '#' 被替换成了多少个 ')'。若替换方案不止一种，输出任意一种即可。

注：一个字符串是有效括号字符串当且仅当它的左右括号个数相等，且任意前缀的左括号个数不超过右括号个数。

进阶：你能做到一次遍历吗？

进阶 2：如果要计算所有合法方案数要怎么做？(提问@七水)
如果 ## 替换成 )+)) 和 ))+) 算不同方案呢？算同一种方案呢？
https://codeforces.com/contest/1281/problem/B

输入 t(≤1500) 表示 t 组数据，每组数据输入两个字符串 s 和 c，长度不超过 5000，由大写字母组成。
你可以交换 s 中的至多一对字符，得到 s'，问能否使 s' < c（即 s' 的字典序严格小于 c）。
若能则输出任意一个符合要求的 s'，否则输出 "---"。
所有数据的 s 和 c 的长度之和各不超过 5000。

进阶：你能实现一个线性时间复杂度的做法吗？
https://codeforces.com/contest/1467/problem/C

输入三个不超过 3e5 的正整数 n1 n2 n3，且 n1+n2+n3≤3e5。
然后输入三个长度分别为 n1 n2 n3 的整数数组，数组元素均在 [1,1e9] 内。

每次操作你可以选择两个非空数组 a 和 b，把 a 中的一个数字 x 移除掉，然后把 b 中的一个数字 y 修改为 y-x。
这样操作 n1+n2+n3-1 次后，就只剩下一个数字了，输出这个数字的最大值。
https://codeforces.com/problemset/problem/297/B

输入三个正整数 n(≤1e5) m(≤1e5) 和 k(≤1e9)。
在海洋中有 k 种鱼类，编号从 1 到 k。设编号为 i 的鱼的重量为 wi，你不知道 wi 的具体数值，但是你知道 0<w1≤w2≤...≤wk，注意 wi 可以为小数。

接下来输入一个长为 n 的数组 a 和一个长为 m 的数组 b，表示 A 抓到了 n 条鱼，第 i 条鱼的种类为 a[i]，B 抓到了 m 条鱼，第 i 条鱼的种类为 b[i]。
如果存在某个序列 w，使得 A 抓到的鱼的重量之和严格大于 B 抓到的鱼的重量之和，输出 YES，否则输出 NO。
https://codeforces.com/problemset/problem/1203/D2

输入两个字符串 s 和 t，长度均不超过 2e5，且由小写字母组成。保证 t 是 s 的子序列。
请你从 s 中删除一个最长的子串，使得 t 仍然是剩下的 s' 的子序列。
输出这个最长子串的长度。
https://codeforces.com/problemset/problem/1196/D2

输入 t(<=2e5)，表示有 t 组数据。
每组数据输入 n 和 k（1<=k<=n<=2e5)，和一个长为 n 的字符串 s，包含 RGB 三种字符。
输出至少修改 s 的多少个字符，可以使 s 中存在一个长度至少为 k 的 RGB 子串。
RGB 子串指无限长字符串 RGBRGBRGB... 的子串。
输入保证这 t 组数据的 n 的和不超过 2e5。
https://codeforces.com/contest/44/problem/H

输入一个旧号码 s，长度不超过 50，只包含 0~9。

你可以按照如下规则生成一个长度和 s 相同的新号码 t：
1. t[0] = 任意一个 0~9 的数字；
2. t[i] = (t[i-1]+s[i])/2   注意：如果除 2 余 1，t[i] 必须上取整或下取整，否则不变。

输出你可以生成多少个和旧号码不同的新号码。
https://codeforces.com/problemset/problem/1051/D

输入整数 n(1<=n<=1000) 和 k(1<=k<=2n)。

你需要对一个 2 行 n 列的网格染色，每个格子需要染成白色或黑色中的一种。
输出网格中有 k 个同色连通块的染色方案数，模 998244353 的结果。

同色连通块指四方向相邻且同色的格子组成的(极大)区域，结合图片理解。
https://codeforces.com/problemset/problem/573/B

输入 n(1<=n<=1e5) 和一个长为 n 的数组 h(1<=h[i]<=1e9)。
给你 n 个积木塔，这些积木塔竖着并列摆放在地板上，均由相同的积木组成，第 i 个积木塔包含 h[i] 个积木。
如果一个积木，其上下左右都是积木或地板，那么它叫做内部积木，否则叫做外部积木。
每一时刻，你可以消除所有的外部积木。
输出消除所有积木所需的时间。
https://codeforces.com/problemset/problem/1081/B

输入 n(1<=n<=1e5) 和一个长为 n 的数组 a(0<=a[i]<=n-1)。
请你构造一个长度为 n 的数组 b，对于每个 b[i]，需要满足 b 中恰好有 a[i] 个元素和 b[i] 不同。
要求 1<=b[i]<=n。
如果不能构造，输出 "Impossible"；否则输出 "Possible" 和任意一个满足要求的数组 b。
http://codeforces.com/problemset/problem/468/A

输入整数 n(1<=n<=1e5)。
一开始黑板上写了 n 个数：1,2,3,4,...,n。
每次操作，你可以擦掉黑板上的两个数字 a 和 b，然后选择将 a+b，a-b 或 a*b 的其中一个写在黑板上。
这样操作恰好 n-1 次后，最终黑板上就只剩下一个数字了。
你能最终得到 24 吗？
若不能，输出 "NO"；否则输出 "YES" 和具体操作方案，输出的格式形如
"a + b = c"（注意空格）。若有多种操作方案，输出任意一种即可。
https://codeforces.com/problemset/problem/639/B

【易错题】
输入三个正整数 n(2<=n<=1e5), d 和 h(1<=h<=d<=n-1)。

请你构造一棵有 n 个节点，直径为 d，高度为 h 的无向树。
若无法构造，输出 -1；否则输出这棵树，用 n-1 条边表示（任意一种合法构造方案均可，节点的编号从 1 开始）。

直径：树上任意两节点的最远距离。
高度：节点 1 和任意节点的最远距离。
https://codeforces.com/contest/1015/problem/D

输入正整数 n(2<=n<=2e9), k(1<=k<=2e5) 和 s(1<=s<=1e18)。
在数轴上有 1,2,3,...,n 共 n 个整点（位置），你一开始在 1 上。
每一步你可以移动到任意位置上（但不能原地不动），移动的距离就是两个位置的距离。
问能不能恰好走 k 步，使得移动的距离之和恰好为 s？
若不能，输出 "NO"；否则输出 "YES" 和 k 个数，表示每一步移动之后的位置。
https://codeforces.com/problemset/problem/1372/C

输入 t 表示 t 组数据，每组数据输入一个正整数 n(<=2e5) 和一个长为 n 的 1~n 的排列 a。
每次操作，你可以选择 a 的一个子数组，将其错排（错排前后，子数组同一位置上的元素不能相同）。
输出将 a 变为升序，至少需要几次操作。

https://codeforces.com/problemset/problem/1084/C

输入一个字符串 s，长度不超过 1e5，只由小写字母组成。
请你求出满足如下条件的 s 的下标序列 p 的个数：

1. p[i] < p[i+1]；
2. s[p[i]] 均为 'a'；
3. s[p[i]] 和 s[p[i+1]] 之间至少有一个 'b'。

输出答案模 1e9+7 的结果。
https://codeforces.com/problemset/problem/788/A

输入 n(<=1e5) 和长为 n 的整数数组 a(-1e9<=a[i]<=1e9)。
在满足 1<=l<r<=n 的前提下，输出 f(l,r) 的最大值（下列式子中的数组下标从 1 开始）。
https://codeforces.com/problemset/problem/1105/C

输入正整数 n(<=2e5)，l 和 r(1<=l<=r<=1e9)。
求有多少个不同的长为 n 的数组，数组元素值的范围为 [l,r]，且数组元素之和为 3 的倍数。
答案对 1e9+7 取模。
https://codeforces.com/problemset/problem/166/E

输入正整数 n(n<=1e7)。
一只蚂蚁站在一个四面体的某个顶点 D 上，沿着四面体的棱行走。
输出它走了恰好 n 条棱后，又重新回到顶点 D 的路径数，模 1e9+7 的结果。
路径中间可以经过 D。
https://codeforces.com/problemset/problem/1025/C

给你一个字符串 s，仅包含 'b' 和 'w'，长度不超过 1e5。

每次操作你可以任意选择一个位置 k，把字符串分为长为 k 的前缀和长为 len(s)-k 的后缀，反转前缀和后缀，再重新拼起来，得到一个新字符串代替原来的 s。（用 Python 来说就是 s = s[:k][::-1] + s[k:][::-1]）
k 可以为 0，即翻转整个 s。

你可以操作任意多次。请输出你能得到的最长 bw 交替子串（形如 bwbwbw... 或 wbwbwb...）的长度。
https://codeforces.com/contest/1009/problem/D

定义互质图：图中每条边所连接的两个点必须是互质的（但互质的两个点之间不一定要有边）。
图中点的编号从 1 到 n。

输入两个整数 n 和 m（范围都在 [1,1e5]）。
请你构造一个有 n 个点 m 条边的无向连通互质图，图中不能有自环（自己连向自己）或重边（多条一样的边）。
如果无法构造，输出 "Impossible"；否则输出 "Possible" 和 m 条边（输出任意一种合法的构造方案）。
https://codeforces.com/contest/518/problem/A

给你两个长度相同（不超过 100），均由小写字母组成的字符串 s 和 t，且 s 的字典序小于 t。

请你输出字典序在 s 和 t 之间的，长度相同且由小写字母组成的任意一个字符串。

若不存在这样的字符串，输出 "No such string"。
https://codeforces.com/problemset/problem/1042/C

【易错题】
输入 n(2<=n<=2e5) 和一个长为 n 的数组 a(-1e9<=a[i]<=1e9)。

你有两个操作：
1. 选择两个未被删除的数字 a[i] 和 a[j]，把 a[i] 删掉，把 a[j] 变为 a[i]*a[j]。
2. 删除一个未被删除的数字 a[i]，该操作至多只能执行一次。

你需要操作 n-1 次，使得最后剩下的那个数字最大。
你不需要输出这个最大数，而是输出你的操作方案（多种方案输出任意一种）。

输出的格式：
操作 1 应输出 "1 i j"
操作 2 应输出 "2 i"

下标从 1 开始。
https://codeforces.com/problemset/problem/439/C

【易错题】
输入整数 n, k(1<=k<=n<=1e5) 和 p(0<=p<=k)，以及 n 个不同的整数表示数组 a（1<=a[i]<=1e9)。

请你将 a 分割为 k 个子序列（子序列不要求连续），使得恰好有 p 个子序列的和均为偶数，k-p 个子序列的和均为奇数。

若不能分割，输出 "NO"；否则输出 "YES" 和 k 行，每行第一个数表示子序列的大小，然后是子序列的数。
输出任意一种合法方案，输出的顺序与输入的顺序无关。
https://codeforces.com/problemset/problem/739/A

定义 mex(S) 表示不在数组 S 中的最小的非负整数。

输入 n(<=1e5) 和 m(<=1e5)，以及 m 个区间左右端点 l[i] 和 r[i]（下标从 1 开始）。
请你构造一个长为 n 的数组 a，使得 min(mex(a[l[i]..r[i]])) 最大，即最大化这 m 个子数组的 mex 的最小值。
输出最大化的值，以及数组 a。

数组 a 的元素值需要在 [0,1e9] 内。
https://codeforces.com/problemset/problem/1283/E

输入 n(<=2e5) 和长为 n 的数组 a(1<=a[i]<=n)。

对于每个 a[i]，你可以将其 +1 或 -1，每个 a[i] 至多修改一次。

输出修改后的 a 的不同元素个数的最小值和最大值。

不同元素个数即 len(set(a))。
https://codeforces.com/problemset/problem/1096/D

给你一个 n(<=1e5)，一个长为 n 的字符串 s 和一个长为 n 的数组 a(1<=a[i]<=998244353)。
表示每个 s[i] 都有一个对应的删除代价 a[i]。

请你删除 s 中的某些字符，使得 s 不包含 "hard" 子序列。
输出被删除字母的代价之和的最小值。

子序列不要求连续。s 仅包含小写字母。
https://codeforces.com/problemset/problem/1691/D

输入 t(≤1e5) 表示 t 组数据，每组数据输入 n(≤2e5) 和长为 n 的数组 a (-1e9≤a[i]≤1e9)。所有数据的 n 之和不超过 2e5。

请你判断，对数组 a 的每个非空子数组 b，是否都有 max(b) >= sum(b)？
如果是，输出 YES，否则输出 NO。
注：子数组是连续的。

进阶：做到 O(n) 时间复杂度。
https://codeforces.com/contest/1038/problem/D

给你一个 n(1<=n<=5e5) 和一个长为 n 的数组 a（-1e9<=a[i]<=1e9)，表示有 n 个卡比排成一排，每个卡比有个分数 a[i]。

每次你可以选择一个卡比，让它吃掉它左边或者右边的一个相邻的卡比，吃完后它的分数要减掉所吃的卡比的分数。

如此操作 n-1 次后，最后剩下的那只卡比的分数的最大值是多少？
https://codeforces.com/problemset/problem/1446/B

背景：最长公共子序列（LCS） https://leetcode-cn.com/problems/longest-common-subsequence/

给你 n,m(<=5000)，长为 n 的字符串 s，长为 m 的字符串 t。定义 LCS(x,y) 表示字符串 x 和 y 的最长公共子序列。

请你选择 s 的子串 s'，t 的子串 t'，最大化 4*len(LCS(s',t'))-len(s')-len(t') 的值。
输出这个最大值。

输入的字符串只包含小写字母。

子串是连续的，子序列不要求连续。
https://codeforces.com/contest/1092/problem/C

给你一个整数 n(2<=n<=100) 和 2n-2 个字符串，这 2n-2 个字符串恰好是某个未知的字符串的所有真前缀和真后缀，即长度从 1 到 n-1 的字符串各有两个。

请按输入顺序回答每个字符串是前缀还是后缀，前缀输出 'P'，后缀输出 'S'，如果答案不止一种，回答任意一种即可。

字符串均由小写字母组成。
https://codeforces.com/problemset/problem/1280/B

给你 T(<=2e4) 表示有 T 组数据。
每组数据给你 r(<=60) 和 c(<=60)，保证所有数据的 r*c 之和不超过 3e6。
然后给你 r 行字符串，每行长度为 c，组成了一个只有 'A' 和 'P' 的网格图。

每次操作，你可以选择某一行的某一段，假设这一段是一把颜料刷，将其向上或者向下移动任意长度，每次移动都会用颜料刷替换对应的段（具体见图）。
你也可以选择某一列的某一段，将其向左或者向右移动任意长度，每次移动都会用颜料刷替换对应的段。

输出最少需要操作几次可以让整个网格图全为 'A'，若无法做到则输出 "MORTAL"。
https://codeforces.com/problemset/problem/847/E

给你一个整数 n(<=1e5) 和一个长为 n 的字符串 s（包含 P*. 三种字符，其中 'P' 表示动物，'*' 表示食物，'.' 表示空地）。
所有动物每单位时间均能移动一个单位，动物移动到食物上就会吃掉食物，吃掉食物的时间忽略不计。
所有动物可以一起移动。请问吃掉所有食物最少需要多少时间。
https://codeforces.com/problemset/problem/1136/D

给你整数 n(<=3e5) 和 m(<=5e5) 表示有 n 个编号从 1 到 n 的人，m 对交换信息。
然后给你一个 1 到 n 的排列 a，表示这 n 个人从左到右排成一队。
然后给你 m 个互不相同的对 (x,y)，表示若 x 和 y 相邻且 x 在 y 左侧，则 x 可以和 y 交换位置。
输出队尾那个人最多可以向左移动多远（他到队尾的距离）。
https://codeforces.com/problemset/problem/922/D

给你整数 n(<=1e5)，以及 n 个仅由字符 s 和 h 组成的字符串，且这 n 个字符串的长度之和不超过 1e5。
请你重新排列这 n 个字符串，然后拼成一个长字符串，使得 "sh" 子序列的出现次数最多。输出这个最大值。
注：子序列不要求连续。
https://codeforces.com/problemset/problem/1082/B

【易错题】
给你整数 n(<=1e5) 和一个长度为 n 的字符串 s，只包含 G 和 S。
你可以至多交换一次 s 中的任意两个字符，求最长连续 G 的长度。

输入 n=10, s="GGGSGGGSGG"
输出 7
解释 把第一个 S 和最后一个 G 交换，得到 "GGGGGGGSGS"
https://atcoder.jp/contests/agc007/tasks/agc007_b

输入 n(<=20000) 和一个 1~n 的排列 p。

请你构造两个长度为 n 的数组 a 和 b，满足：
1. 元素值在 [1,1e9]
2. a 严格单调递增
3. b 严格单调递减
4. a[p[i]]+b[p[i]] 严格单调递增，即 a[p[0]]+b[p[0]] < a[p[1]]+b[p[1]] < ...

输出任意符合上述要求的 a 和 b。
https://codeforces.com/problemset/problem/939/E

一开始你有一个空数组 a。
接下来有 Q(<=5e5) 次操作或询问。
操作（用 1 和 x 表示）是往 a 的末尾添加一个在 [1,1e9] 的数字 x，保证添加后 a 仍然是非降的。
询问（用 2 表示）是请你选择 a 中的一个子序列（不要求连续）b，最大化 max(b)-avg(b)，这里 avg(b) 为 b 的平均值。
对于每个询问，输出 max(b)-avg(b) 的最大值。（保留 8 位小数即可）
https://codeforces.com/problemset/problem/732/D

接下来的 n(<=1e5) 天你需要参加 m(<=1e5) 门课程的考试。
给你一个长度为 n 的数组 d，d[i]=0 表示第 i 天没有考试，否则表示第 i 天有第 d[i](1<=d[i]<=m) 门课程的考试。
还有一个长度为 m 的数组 a，表示第 i 门考试需要花费 a[i](1<=a[i]<=1e5) 天的时间备考，才能通过。
如果你在某一天参加了考试，那么你当天不能备考。
备考同一门课程的时间不需要连续。
请输出参加并通过这 m 门考试的最小天数（天数从 1 开始）。若无法做到，输出 -1。
https://codeforces.com/problemset/problem/1118/E

给你两个数 m 和 n（均在 [2,2e5] 范围内）
请你构造 m 个互不相同的 pair，需满足：
1. 每个 pair 包含两个在 [1,n] 内的不同整数。
2. 两个相邻的 pair，第一个数不能相同，第二个数也不能相同。
如果不能构造，输出 NO，否则输出 YES 和这 m 个 pair
https://codeforces.com/problemset/problem/723/C

给你一个数组 a，长度不超过 2000，元素值在 [1,1e9]。另外还给你一个数 m (1<=m<=n)。
每次修改操作你可以将某个 a[i] 修改为任意数字。
定义 count(v) 表示 v 在 a 中的出现次数。
请你修改 a，最大化 min(count(v)), v in [1,m]，即最大化 count(1), count(2), ..., count(m) 的最小值。
按顺序输出：最大化的结果、最小修改次数、修改之后的 a。
https://codeforces.com/problemset/problem/209/A

求一个长为 n(<=1e6) 的 01 交替串中有多少个 01 交替子序列。对结果模 1e9+7。

注意子序列不要求连续。
https://codeforces.com/problemset/problem/305/C

给你一个有序数组 a，长度不超过 1e5，0<=a[i]<=2e9。
请你求出 2^a[0]+2^a[1]+...+2^a[n-1] 的二进制中的 0 的个数。（^ 表示幂）
https://codeforces.com/problemset/problem/156/B

有 n(<=1e5) 个人，编号从 1 到 n。其中恰好有一个人是罪犯。
同时还有 n 条陈述，每条陈述要么是 +x，表示 x 是罪犯；要么是 -x，表示 x 不是罪犯。(1<=x<=n)
已知这 n 条陈述中恰好有 m(<=n) 条是实话，有 n-m 条是假话。
对于每条陈述，如果这条陈述一定是实话，输出 "Truth"；如果一定是假话，输出 "Lie"；如果不确定是真是假，输出 "Not defined"。
https://codeforces.com/problemset/problem/689/D

给你两个数组 a b，长度均为 n(n<=2e5)，元素范围 [-1e9,1e9]。
求所有满足 max(a[l..r]) = min(b[l..r]) 的区间 [l,r] 的个数。
https://codeforces.com/problemset/problem/949/A

给你一个只包含 01 的字符串 s，长度不超过 2e5。

请你将 s 拆分成若干个子序列（子序列不要求连续），使得每个子序列都是长度为奇数的，从 0 开始的 01 交替串，例如 0 010 01010 等等

如果无法拆分，输出 -1；否则输出组成这些子序列的下标数组（从 1 开始）。可以输出任意一种符合要求的解。
https://codeforces.com/problemset/problem/712/C

给你两个整数 x 和 y，满足 3<=y<x<=1e5。

从边长为 x 的等边三角形出发，每次操作你可以将其中一条边的长度修改为某个整数，要求修改后的三条边仍能组成一个三角形。

将三角形修改成边长为 y 的等边三角形，最少需要操作多少次？
https://codeforces.com/problemset/problem/1310/A

给你两个数组 a 和 t，长度相同且不超过 2e5，1<=a[i]<=1e9, 1<=t[i]<=1e5。

你可以执行任意多次操作。每次操作，你可以给某个 a[i]+=1，该次操作的花费为 t[i]。

请问要使 a 中所有数字均不相同，最小花费是多少？
https://codeforces.com/problemset/problem/960/C

给你两个数 x 和 d，范围在 [1,1e9] 内。

定义一个非空子序列 b 是好的，需满足 max(b)-min(b) < d

请你构造任意一个满足要求的整数数组 a，要求 a 的长度不超过 1e4，a[i] 均在 [1,1e18] 范围内，且满足：

a 恰好有 x 个非空好子序列。（子序列不要求是连续的）

如果无法构造，输出 -1；否则输出 a 的长度和 a 的元素。
https://codeforces.com/contest/358/problem/D

给你 3 个长度均为 n(<=3000) 的数组 a b c，元素范围 [0,1e5]，具体含义见下文。

有 n 个物品排成一排，你可以按照任意顺序拿物品，并获得相应的分数：

1. 如果拿走某个物品时，相邻两个物品都没有被拿过，那么得到的分数为 a[i]
2. 如果相邻的两个物品恰好有一个被拿过，那么得到的分数为 b[i]
3. 如果相邻的两个物品都被拿走了，那么得到的分数为 c[i]

问拿走所有物品后，能够获得的最高分数为多少？
https://codeforces.com/problemset/problem/33/C

给你一个长为 n(<=1e5) 的数组，元素范围 [-1e4,1e4]。

你可以选择一段前缀和一段后缀（可为空），将所有被选择的元素改为其相反数（a[i] 变成 -a[i]）

问修改后的数组的所有元素之和的最大值。
https://codeforces.com/problemset/problem/747/D

给你 n(<=2e5) 个数表示每天的温度 t[i] (-20<=t[i]<=20)，到达目的地需要 n 天。

你有两个轮胎，雪地胎和普通胎。
雪地胎可以在任何温度行驶，但只能用 k(<=n) 天。（不一定要连续使用 k 天）
普通胎只能在温度不为负的时候行驶，使用天数无限制。

你一开始用的是普通胎。在每天开始可以选择更换为另一种轮胎。

问这 n 天需要最少换几次轮胎？若无法做到则输出 -1。
https://codeforces.com/problemset/problem/797/C

给你一个字符队列 s，长度不超过 1e5，由小写字母组成。
你还有一个空栈。

每次你可以执行下列操作之一，直到队列和栈均为空：
- 弹出队首字符，将其入栈。
- 弹出栈顶字符。

输出字典序最小的出栈序列。
https://codeforces.com/problemset/problem/815/A

输入一个 n 行 m 列的矩阵，n 和 m 不超过 100，元素值均在 [0,500] 内。
请你判断能否从一个 n 行 m 列的零矩阵开始，每次操作给某一行全部 +1 或某一列全部 +1，来生成输入的矩阵。
若不能，输出 -1。若能，输出最少操作多少次，以及具体操作方案（任意顺序）：若操作在第 i 行上，输出 "row i"，操作在第 j 列上，输出 "col j"。
https://codeforces.com/problemset/problem/197/A

有一张长为 a 宽为 b 的桌子，以及数量无限的半径为 r 的圆形盘子（a b r 均为 [1,100] 的整数）
Alice 和 Bob 先后往桌子上放盘子，盘子之间不能重叠，且不能超出桌子的边界（可以紧贴边界或其它盘子）。无法放盘子的人输，另一个人赢。
如果先手能赢则输出 First，否则输出 Second。

https://codeforces.com/problemset/problem/1148/D

给你 n(<=3e5) 个 pair，每个 pair 有两个整数。这 2n 个数各不相同，且元素值在 [1,2n] 中。

现在让你选择 k 个 pair，将这 k 个 pair 重新排列后（pair 内的数字顺序不变），组成一个振荡序列（不能出现连续两个递增或连续两个递减）。

比如 [(1,7), (6,4), (2,10), (9,8), (3,5)]
选择 (1,7) (3,5) (2,10)
得到振荡序列 1,7,3,5,2,10

求 k 的最大值，和组成序列的 pair 的下标。

https://codeforces.com/problemset/problem/429/B

给你一个网格图，长宽均不超过 1000，每个格子有一个分数 0<=a[i][j]<=1e5。

有两个人 A 和 B：
A 从左上角出发到右下角，每次只能向下或向右；
B 从左下角出发到右上角，每次只能向上或向右。

两人所走的路径必须恰好只在一个格子相交。注意是路径相交，两人不一定要相遇。

求去掉这个相交的格子后，其余在路径上的格子的分数之和的最大值。
https://codeforces.com/problemset/problem/778/A

给你两个字符串 s 和 t（保证 t 是 s 的子序列），s 由小写字母组成，长度不超过 2e5。

再给你一个由 s 的所有下标组成的排列 p，设 p 的长为 x 的前缀为 p[:x]，你需要从 s 中删掉所有下标在 p[:x] 中的字符，得到字符串 s'。

输出满足 t 为 s' 的子序列的最大的 x。

注意子序列不要求连续。
https://codeforces.com/problemset/problem/878/A

给你两个长度不超过 5e5 的数组 op 和 val，其中 op[i] 为 & | ^ 三种位运算中的一种，0<=val[i]<=1023
这表示如下函数 f，它接收一个整数 x(0<=x<=1023)，经过若干位运算后，再返回这个数

def f(x: int) -> int:
    x = x op[1] val[1]
    x = x op[2] val[2]
    ...
    x = x op[n] val[n]
    return x

请你写一个结构与 f 类似的新函数 g，其至多包含 5 对 op' 和 val'，且对任意 0<=x<=1023 均满足 f(x) = g(x)
输出 g 中的 op' 和 val'（其中 op'[i] 为 & | ^ 三种位运算中的一种，0<=val'[i]<=1023）
http://codeforces.com/problemset/problem/282/C

给你两个 01 串 s 和 t，长度均不超过 1e6，你可以对 s 执行任意次如下操作：

选择两个相邻的数字 x 和 y，计算出 p=x^y (xor) 和 q=x|y (or)，
然后替换 x 为 p，y 为 q；或者替换 x 为 q，y 为 p。

判断能否将 s 变为 t。

https://codeforces.com/problemset/problem/163/A

给你两个字符串 s 和 t，只包含小写字母，长度均不超过 5000，求所有 (x,y) pair 的个数，满足：
1. x 是 s 的子串
2. y 是 t 的子序列
3. x 等于 y

请注意，在计算 (x,y) pair 时，重复的子串或子序列应视作多个不同的 (x,y) pair。例如：
s = "aa", t = "a"，那么 (s[:1],t) 和 (s[1:], t) 都是合法答案，因此答案为 2。

由于答案可能很大，输出答案对 1e9+7 取模后的结果。

http://codeforces.com/problemset/problem/439/D

给两个数组 a 和 b，长度均不超过 1e5，元素范围为 [1,1e9]。
每次操作可以使 a 或 b 中的任意元素 +1 或 -1，求使 min(a) >= max(b) 的最小操作次数。
https://codeforces.com/problemset/problem/924/C

有一条河，河的水位会在接下来的 n(<=1e5) 天发生变化。（见右图）
记录员每天会在当天水位处画一条线（如果已经有线就不画），并记录在水位上方的线的数目 m[i] (0<=m[i]<i)。
河水不会把线冲刷掉。第 1 天之前没有画线。

令 d[i] 表示第 i 天在水位下方的线的数目。
求 sum(d) 的最小值。

https://codeforces.com/problemset/problem/913/C

有 n(<=30) 种不同的饮料，第 i（i 从 0 开始）种饮料的体积为 2^i 升，价格为 c[i](<=1e9)，每种饮料的数量无限。

求购买至少 L(<=1e9) 升的饮料至少需要多少钱？
http://codeforces.com/problemset/problem/893/D

你有一张奇怪的信用卡，初始金额为 0。
每天早上你可以去银行给卡充任意金额的钱。（也可以不去）
给你一个长度为 n(<=1e5) 的数组，第 i 天晚上会发生如下情况：（-1e4<=a[i]<=1e4）
如果 a[i]>0，卡里的钱自动增加 a[i]
如果 a[i]<0，卡里的钱自动减少 |a[i]|（卡里的钱可以为负的）
如果 a[i]=0，银行会查询卡里的余额，如果此时卡里的钱为负则会冻结信用卡。
并且，在任意时刻，卡里的钱都不能超过 d(1<=d<=1e9)。
为了不让卡被冻结，请问你至少要去银行几次（给卡充钱）？
如果无论如何卡里的钱都会超过 d，则输出 -1。
https://codeforces.com/problemset/problem/827/A

有一个未知的字符串 s（长度也未知），输入 n(<=1e5) 个子串的信息，每条信息包含一个子串和该子串在 s 中的至少哪些位置出现过。（输入的子串的长度之和 <=1e6，位置的个数 <=1e6，位置的下标<=1e6）

请你根据上述信息还原出一个字典序最小的 s。（保证 s 存在）
给你一个数组 a，长度不超过 3e5，1<=a[i]<=1e9。
你可以执行任意次操作，每次操作可以让某个 a[i]+=1，花费为 b[i] (1<=b[i]<=1e9)。
求使 a 任意相邻数字均不同的最小花费。
可以对同一个 a[i] 多次 +1。

https://codeforces.com/problemset/problem/1221/D
给你一个无向连通图，点 <=2e5，边 <= 2e5（无重边无自环），每个点有一个高度 h[i] (0<=h[i]<=1e8)，对于每条边 v-w，从 v 到 w 对快乐度的影响如下：

h[v] > h[w]：增加 h[v]-h[w]
h[v] < h[w]：减少 2*(h[w]-h[v])
h[v] = h[w]：不变

求从点 1 出发，能获得的快乐度最大是多少。

https://atcoder.jp/contests/abc237/tasks/abc237_e
背景：最长公共子序列（LCS） https://leetcode-cn.com/problems/longest-common-subsequence/

给你三个字符串 s1、s2 和 t，长度均不超过 100，且仅包含大写字母。你需要求出 s1 和 s2 的 LCS，并且 t 不能是 LCS 的子串（或者说 LCS 不能包含 t）。如果没有 LCS 则输出 0。

请注意，子串一定是连续的，子序列可以是不连续的。

https://codeforces.com/problemset/problem/346/B
背景：最大子段和 https://leetcode-cn.com/problems/maximum-subarray/

有 n(<=50) 个小数组，每个小数组的长度不超过 5000，元素值在 [-1000,1000] 范围内。
现在有一个压缩数组，由 m(<=250000) 个范围在 [1,n] 的下标组成，每个下标对应一个小数组。
求压缩数组解压后（用小数组替换下标）组成的大数组的最大子段和。

https://codeforces.com/problemset/problem/75/D
给你一个的正整数 s（以长度不超过 1e5 的字符串形式表示，无前导零）。
要求删掉尽可能少的数字，使得删数后的 s' 能被 3 整除且 s' 无前导零。

输出 s'。如果无法得到符合要求的 s'，输出 -1。

https://codeforces.com/contest/792/problem/C
在一条直线上有 n(<=1000) 个员工和 k(n<=k<=2000) 把钥匙。
n 个人的坐标为 a[i](1~1e9), k 把钥匙的坐标为 b[j](1~1e9)。
办公室位于坐标 p(1~1e9)。

员工的速度为一个单位。所有员工都必须要取得一把钥匙才能进入办公室。
一个坐标上的钥匙被拿了就没有了。

输出所有人均到达办公室的最短时间。

https://codeforces.com/problemset/problem/830/A
你的公司有 n(<2e5 且为奇数) 名员工，你需要给他们发共计不超过 s(<=1e14) 的工资，对于第 i 位员工，他的工资应该在区间 [l[i], r[i]] 范围内(1<=l[i]<=r[i]<=1e9)。

保证 s 不小于所有 l[i] 之和。

问如何分配 s 可以使这 n 个人的工资的中位数最大。输出这个最大中位数。

https://codeforces.com/problemset/problem/1251/D
给你一个长度不超过 1e5 的数组（元素范围在 -1e9 ~ 1e9），你要执行恰好三次操作，使得操作结束后数组所有数均为 0。

每次操作你需要选择一个区间（设区间长度为 len），对于区间内的数，加上 len 的任意倍（倍数可正可负可为 0）。注意这对每个数是互相独立的，比如 len=3，那么你可以给区间内的第一个数加 6，第二个数减 9，第三个数加 0。

请你给出任意一个合法方案，可以证明这个问题一定有解。

每个操作输出两行，第一行为区间左右端点（下标从 1 开始），第二行为每个数在该次操作下的变化量（需要能被 len 整除）。

https://codeforces.com/problemset/problem/1396/A
给定一个长度不超过 2e5 的含有 abc? 四种字符的字符串，每个 ? 必须替换成是 abc 中的一个。（不同位置的 ? 的替换是互相独立的）

设 ? 的个数有 k 个，那么替换后一共有 3^k 个不同的只包含 abc 的字符串。

求这 3^k 个字符串中，子序列 abc 的出现次数之和。（对 1e9+7 取模）

https://codeforces.com/problemset/problem/1426/F
给你 n(<=1e5) 个浮点数 (绝对值不超过 1e5)，记作数组 a，保证这 n 个数的和为 0。
你需要构造任意一个数组 b，满足 b[i] = floor(a[i]) 或者 b[i] = ceil(a[i])，且 sum(b) = 0

https://codeforces.com/problemset/problem/1186/D
给你一个长度不超过 2e5 的字符串 s，和一个长度不超过 2e5 的字符串 t，求 s 的不同排列个数，满足这个排列是 t 的子串。

字母均为小写字母。
背景：LC54. 螺旋矩阵 https://leetcode-cn.com/problems/spiral-matrix/

问题：给你 n 和 m，表示 n x m 的螺旋矩阵（n,m 均不超过 1e9），有 q(<=1e5) 个查询，查询要么是 "1 k"，要么是 "2 x y"，解释如下：
1. 输出从左上角 (1,1) 出发，走 k (k<n*m) 步后的坐标；
2. 输出从左上角 (1,1) 出发，走到 (x,y) 需要的步数。
背景：对于「求一个数组有多少个没有重复元素的非空子区间」这样的问题，我们可以用双指针法求出答案。

问题：给出数组长度 n(<=1e5)、元素值上界 m(<=1e5) 和上述问题的答案 k(<=1e10)，请你构造出任意一个元素值在 [1,m] 范围内的整型数组，使得用该数组作为输入时，上述问题的输出恰好为 k。若无法构造，输出 -1。
给你一个 3 x 3 的矩阵，矩阵中的某些位置上已经填入了整数，范围 [-1e9,1e9]。现在让你给其余位置都填入整数，使得矩阵每行每列的三个数均组成一个等差数列（公差可以为任意整数）。无解时输出 -1，否则输出任意一个符合要求的 3 x 3 矩阵。
给你一个长为 n(<=1e5) 的上界数组 up（up[i]<=1e5），求其最长前缀（设长度为 x），使得存在一个 1~x 的排列 p，满足 p[i] <= up[i]
背景：
01 字典树（又叫异或字典树）可以用于解决一类“数组中的两个数的最大异或和”等问题（如力扣 421 题）。
代码实现时，需要将每个数字视作一个长度固定的 01 字符串插入字典树。

问题：
给你 n(<=1e5) 和 m(<=1e9)，请你构造出一个长度为 n 的数组，且每个元素的范围为 [0,m]，使得用户在做 421 题时，以该数组作为输入时，所生成的字典树中的节点个数最大。
求任意一个符合上述要求的数组，以及对应的最大节点个数。
解答见右
























































































































































































